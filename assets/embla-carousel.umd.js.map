{"mappings":"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","sources":["<anon>","src/js/embla-carousel.umd.js"],"sourcesContent":["(function () {\nvar $c680b46bbc90729e$exports = {};\n// embla-carousel@8.2\n!function(n, t) {\n    $c680b46bbc90729e$exports = t();\n}($c680b46bbc90729e$exports, function() {\n    \"use strict\";\n    function n(n) {\n        return \"number\" == typeof n;\n    }\n    function t(n) {\n        return \"string\" == typeof n;\n    }\n    function e(n) {\n        return \"boolean\" == typeof n;\n    }\n    function r(n) {\n        return \"[object Object]\" === Object.prototype.toString.call(n);\n    }\n    function o(n) {\n        return Math.abs(n);\n    }\n    function i(n) {\n        return Math.sign(n);\n    }\n    function c(n, t) {\n        return o(n - t);\n    }\n    function u(n) {\n        return f(n).map(Number);\n    }\n    function s(n) {\n        return n[a(n)];\n    }\n    function a(n) {\n        return Math.max(0, n.length - 1);\n    }\n    function d(n, t) {\n        return t === a(n);\n    }\n    function l(n, t = 0) {\n        return Array.from(Array(n), (n, e)=>t + e);\n    }\n    function f(n) {\n        return Object.keys(n);\n    }\n    function p(n, t) {\n        return [\n            n,\n            t\n        ].reduce((n, t)=>(f(t).forEach((e)=>{\n                const o = n[e], i = t[e], c = r(o) && r(i);\n                n[e] = c ? p(o, i) : i;\n            }), n), {});\n    }\n    function m(n, t) {\n        return void 0 !== t.MouseEvent && n instanceof t.MouseEvent;\n    }\n    function g() {\n        let n = [];\n        const t = {\n            add: function(e, r, o, i = {\n                passive: !0\n            }) {\n                let c;\n                if (\"addEventListener\" in e) e.addEventListener(r, o, i), c = ()=>e.removeEventListener(r, o, i);\n                else {\n                    const n = e;\n                    n.addListener(o), c = ()=>n.removeListener(o);\n                }\n                return n.push(c), t;\n            },\n            clear: function() {\n                n = n.filter((n)=>n());\n            }\n        };\n        return t;\n    }\n    function h(n, t, e, r) {\n        const o = g(), i = 1e3 / 60;\n        let c = null, u = 0, s = 0;\n        function a(n) {\n            if (!s) return;\n            c || (c = n);\n            const o = n - c;\n            for(c = n, u += o; u >= i;)e(i), u -= i;\n            r(u / i), s && t.requestAnimationFrame(a);\n        }\n        function d() {\n            t.cancelAnimationFrame(s), c = null, u = 0, s = 0;\n        }\n        return {\n            init: function() {\n                o.add(n, \"visibilitychange\", ()=>{\n                    n.hidden && (c = null, u = 0);\n                });\n            },\n            destroy: function() {\n                d(), o.clear();\n            },\n            start: function() {\n                s || (s = t.requestAnimationFrame(a));\n            },\n            stop: d,\n            update: ()=>e(i),\n            render: r\n        };\n    }\n    function x(n = 0, t = 0) {\n        const e = o(n - t);\n        function r(t) {\n            return t < n;\n        }\n        function i(n) {\n            return n > t;\n        }\n        function c(n) {\n            return r(n) || i(n);\n        }\n        return {\n            length: e,\n            max: t,\n            min: n,\n            constrain: function(e) {\n                return c(e) ? r(e) ? n : t : e;\n            },\n            reachedAny: c,\n            reachedMax: i,\n            reachedMin: r,\n            removeOffset: function(n) {\n                return e ? n - e * Math.ceil((n - t) / e) : n;\n            }\n        };\n    }\n    function y(n, t, e) {\n        const { constrain: r } = x(0, n), i = n + 1;\n        let c = u(t);\n        function u(n) {\n            return e ? o((i + n) % i) : r(n);\n        }\n        function s() {\n            return c;\n        }\n        function a() {\n            return y(n, s(), e);\n        }\n        const d = {\n            get: s,\n            set: function(n) {\n                return c = u(n), d;\n            },\n            add: function(n) {\n                return a().set(s() + n);\n            },\n            clone: a\n        };\n        return d;\n    }\n    function v(n, t, r, u, s, a, d, l, f, p, h, y, v, b, S, w, E, L, D) {\n        const { cross: I, direction: A } = n, F = [\n            \"INPUT\",\n            \"SELECT\",\n            \"TEXTAREA\"\n        ], M = {\n            passive: !1\n        }, T = g(), O = g(), P = x(50, 225).constrain(b.measure(20)), z = {\n            mouse: 300,\n            touch: 400\n        }, H = {\n            mouse: 500,\n            touch: 600\n        }, k = S ? 43 : 25;\n        let V = !1, B = 0, C = 0, N = !1, R = !1, j = !1, G = !1;\n        function q(n) {\n            if (!m(n, u) && n.touches.length >= 2) return U(n);\n            const t = a.readPoint(n), e = a.readPoint(n, I), r = c(t, B), o = c(e, C);\n            if (!R && !G) {\n                if (!n.cancelable) return U(n);\n                if (R = r > o, !R) return U(n);\n            }\n            const i = a.pointerMove(n);\n            r > w && (j = !0), p.useFriction(.3).useDuration(.75), l.start(), s.add(A(i)), n.preventDefault();\n        }\n        function U(n) {\n            const t = h.byDistance(0, !1).index !== y.get(), e = a.pointerUp(n) * (S ? H : z)[G ? \"mouse\" : \"touch\"], r = function(n, t) {\n                const e = y.add(-1 * i(n)), r = h.byDistance(n, !S).distance;\n                return S || o(n) < P ? r : E && t ? .5 * r : h.byIndex(e.get(), 0).distance;\n            }(A(e), t), u = function(n, t) {\n                if (0 === n || 0 === t) return 0;\n                if (o(n) <= o(t)) return 0;\n                const e = c(o(n), o(t));\n                return o(e / n);\n            }(e, r), s = k - 10 * u, d = L + u / 50;\n            R = !1, N = !1, O.clear(), p.useDuration(s).useFriction(d), f.distance(r, !S), G = !1, v.emit(\"pointerUp\");\n        }\n        function W(n) {\n            j && (n.stopPropagation(), n.preventDefault(), j = !1);\n        }\n        return {\n            init: function(n) {\n                if (!D) return;\n                function o(o) {\n                    (e(D) || D(n, o)) && function(n) {\n                        const e = m(n, u);\n                        if (G = e, j = S && e && !n.buttons && V, V = c(s.get(), d.get()) >= 2, e && 0 !== n.button) return;\n                        if (function(n) {\n                            const t = n.nodeName || \"\";\n                            return F.includes(t);\n                        }(n.target)) return;\n                        N = !0, a.pointerDown(n), p.useFriction(0).useDuration(0), s.set(d), function() {\n                            const n = G ? r : t;\n                            O.add(n, \"touchmove\", q, M).add(n, \"touchend\", U).add(n, \"mousemove\", q, M).add(n, \"mouseup\", U);\n                        }(), B = a.readPoint(n), C = a.readPoint(n, I), v.emit(\"pointerDown\");\n                    }(o);\n                }\n                const i = t;\n                T.add(i, \"dragstart\", (n)=>n.preventDefault(), M).add(i, \"touchmove\", ()=>{}, M).add(i, \"touchend\", ()=>{}).add(i, \"touchstart\", o).add(i, \"mousedown\", o).add(i, \"touchcancel\", U).add(i, \"contextmenu\", U).add(i, \"click\", W, !0);\n            },\n            destroy: function() {\n                T.clear(), O.clear();\n            },\n            pointerDown: function() {\n                return N;\n            }\n        };\n    }\n    function b(n, t) {\n        let e, r;\n        function i(n) {\n            return n.timeStamp;\n        }\n        function c(e, r) {\n            const o = \"client\" + (\"x\" === (r || n.scroll) ? \"X\" : \"Y\");\n            return (m(e, t) ? e : e.touches[0])[o];\n        }\n        return {\n            pointerDown: function(n) {\n                return e = n, r = n, c(n);\n            },\n            pointerMove: function(n) {\n                const t = c(n) - c(r), o = i(n) - i(e) > 170;\n                return r = n, o && (e = n), t;\n            },\n            pointerUp: function(n) {\n                if (!e || !r) return 0;\n                const t = c(r) - c(e), u = i(n) - i(e), s = i(n) - i(r) > 170, a = t / u;\n                return u && !s && o(a) > .1 ? a : 0;\n            },\n            readPoint: c\n        };\n    }\n    function S(n, t, r, i, c, u, s) {\n        const a = [\n            n\n        ].concat(i);\n        let d, l, f = [], p = !1;\n        function m(n) {\n            return c.measureSize(s.measure(n));\n        }\n        return {\n            init: function(c) {\n                u && (l = m(n), f = i.map(m), d = new ResizeObserver((r)=>{\n                    (e(u) || u(c, r)) && function(e) {\n                        for (const r of e){\n                            if (p) return;\n                            const e = r.target === n, u = i.indexOf(r.target), s = e ? l : f[u];\n                            if (o(m(e ? n : i[u]) - s) >= .5) {\n                                c.reInit(), t.emit(\"resize\");\n                                break;\n                            }\n                        }\n                    }(r);\n                }), r.requestAnimationFrame(()=>{\n                    a.forEach((n)=>d.observe(n));\n                }));\n            },\n            destroy: function() {\n                p = !0, d && d.disconnect();\n            }\n        };\n    }\n    function w(n, t, e, r, i) {\n        const c = i.measure(10), u = i.measure(50), s = x(.1, .99);\n        let a = !1;\n        function d() {\n            return !a && !!n.reachedAny(e.get()) && !!n.reachedAny(t.get());\n        }\n        return {\n            shouldConstrain: d,\n            constrain: function(i) {\n                if (!d()) return;\n                const a = n.reachedMin(t.get()) ? \"min\" : \"max\", l = o(n[a] - t.get()), f = e.get() - t.get(), p = s.constrain(l / u);\n                e.subtract(f * p), !i && o(f) < c && (e.set(n.constrain(e.get())), r.useDuration(25).useBaseFriction());\n            },\n            toggleActive: function(n) {\n                a = !n;\n            }\n        };\n    }\n    function E(n, t, e, r) {\n        const o = t.min + .1, i = t.max + .1, { reachedMin: c, reachedMax: u } = x(o, i);\n        return {\n            loop: function(t) {\n                if (!function(n) {\n                    return 1 === n ? u(e.get()) : -1 === n && c(e.get());\n                }(t)) return;\n                const o = n * (-1 * t);\n                r.forEach((n)=>n.add(o));\n            }\n        };\n    }\n    function L(n, t, e, r, c) {\n        const { reachedAny: u, removeOffset: a, constrain: d } = r;\n        function l(n) {\n            return n.concat().sort((n, t)=>o(n) - o(t))[0];\n        }\n        function f(t, r) {\n            const o = [\n                t,\n                t + e,\n                t - e\n            ];\n            if (!n) return t;\n            if (!r) return l(o);\n            const c = o.filter((n)=>i(n) === r);\n            return c.length ? l(c) : s(o) - e;\n        }\n        return {\n            byDistance: function(e, r) {\n                const i = c.get() + e, { index: s, distance: l } = function(e) {\n                    const r = n ? a(e) : d(e), i = t.map((n, t)=>({\n                            diff: f(n - r, 0),\n                            index: t\n                        })).sort((n, t)=>o(n.diff) - o(t.diff)), { index: c } = i[0];\n                    return {\n                        index: c,\n                        distance: r\n                    };\n                }(i), p = !n && u(i);\n                return !r || p ? {\n                    index: s,\n                    distance: e\n                } : {\n                    index: s,\n                    distance: e + f(t[s] - l, 0)\n                };\n            },\n            byIndex: function(n, e) {\n                return {\n                    index: n,\n                    distance: f(t[n] - c.get(), e)\n                };\n            },\n            shortcut: f\n        };\n    }\n    function D(t, r, o, i, c, u, s, a) {\n        const d = {\n            passive: !0,\n            capture: !0\n        };\n        let l = 0;\n        function f(n) {\n            \"Tab\" === n.code && (l = (new Date).getTime());\n        }\n        return {\n            init: function(p) {\n                a && (u.add(document, \"keydown\", f, !1), r.forEach((r, f)=>{\n                    u.add(r, \"focus\", (r)=>{\n                        (e(a) || a(p, r)) && function(e) {\n                            if ((new Date).getTime() - l > 10) return;\n                            s.emit(\"slideFocusStart\"), t.scrollLeft = 0;\n                            const r = o.findIndex((n)=>n.includes(e));\n                            n(r) && (c.useDuration(0), i.index(r, 0), s.emit(\"slideFocus\"));\n                        }(f);\n                    }, d);\n                }));\n            }\n        };\n    }\n    function I(t) {\n        let e = t;\n        function r(t) {\n            return n(t) ? t : t.get();\n        }\n        return {\n            get: function() {\n                return e;\n            },\n            set: function(n) {\n                e = r(n);\n            },\n            add: function(n) {\n                e += r(n);\n            },\n            subtract: function(n) {\n                e -= r(n);\n            }\n        };\n    }\n    function A(n, t) {\n        const e = \"x\" === n.scroll ? function(n) {\n            return `translate3d(${n}px,0px,0px)`;\n        } : function(n) {\n            return `translate3d(0px,${n}px,0px)`;\n        }, r = t.style;\n        let o = !1;\n        return {\n            clear: function() {\n                o || (r.transform = \"\", t.getAttribute(\"style\") || t.removeAttribute(\"style\"));\n            },\n            to: function(t) {\n                o || (r.transform = e(n.direction(t)));\n            },\n            toggleActive: function(n) {\n                o = !n;\n            }\n        };\n    }\n    function F(n, t, e, r, o, i, c, s, a) {\n        const d = .5, l = u(o), f = u(o).reverse(), p = (function() {\n            const n = c[0];\n            return h(g(f, n), e, !1);\n        })().concat(function() {\n            const n = t - c[0] - 1;\n            return h(g(l, n), -e, !0);\n        }());\n        function m(n, t) {\n            return n.reduce((n, t)=>n - o[t], t);\n        }\n        function g(n, t) {\n            return n.reduce((n, e)=>m(n, t) > 0 ? n.concat([\n                    e\n                ]) : n, []);\n        }\n        function h(o, c, u) {\n            const l = function(n) {\n                return i.map((e, o)=>({\n                        start: e - r[o] + d + n,\n                        end: e + t - d + n\n                    }));\n            }(c);\n            return o.map((t)=>{\n                const r = u ? 0 : -e, o = u ? e : 0, i = u ? \"end\" : \"start\", c = l[t][i];\n                return {\n                    index: t,\n                    loopPoint: c,\n                    slideLocation: I(-1),\n                    translate: A(n, a[t]),\n                    target: ()=>s.get() > c ? r : o\n                };\n            });\n        }\n        return {\n            canLoop: function() {\n                return p.every(({ index: n })=>m(l.filter((t)=>t !== n), t) <= .1);\n            },\n            clear: function() {\n                p.forEach((n)=>n.translate.clear());\n            },\n            loop: function() {\n                p.forEach((n)=>{\n                    const { target: t, translate: e, slideLocation: r } = n, o = t();\n                    o !== r.get() && (e.to(o), r.set(o));\n                });\n            },\n            loopPoints: p\n        };\n    }\n    function M(n, t, r) {\n        let o, i = !1;\n        return {\n            init: function(c) {\n                r && (o = new MutationObserver((n)=>{\n                    i || (e(r) || r(c, n)) && function(n) {\n                        for (const e of n)if (\"childList\" === e.type) {\n                            c.reInit(), t.emit(\"slidesChanged\");\n                            break;\n                        }\n                    }(n);\n                }), o.observe(n, {\n                    childList: !0\n                }));\n            },\n            destroy: function() {\n                o && o.disconnect(), i = !0;\n            }\n        };\n    }\n    function T(n, t, e, r) {\n        const o = {};\n        let i, c = null, u = null, s = !1;\n        return {\n            init: function() {\n                i = new IntersectionObserver((n)=>{\n                    s || (n.forEach((n)=>{\n                        const e = t.indexOf(n.target);\n                        o[e] = n;\n                    }), c = null, u = null, e.emit(\"slidesInView\"));\n                }, {\n                    root: n.parentElement,\n                    threshold: r\n                }), t.forEach((n)=>i.observe(n));\n            },\n            destroy: function() {\n                i && i.disconnect(), s = !0;\n            },\n            get: function(n = !0) {\n                if (n && c) return c;\n                if (!n && u) return u;\n                const t = function(n) {\n                    return f(o).reduce((t, e)=>{\n                        const r = parseInt(e), { isIntersecting: i } = o[r];\n                        return (n && i || !n && !i) && t.push(r), t;\n                    }, []);\n                }(n);\n                return n && (c = t), n || (u = t), t;\n            }\n        };\n    }\n    function O(t, e, r, i, c, d, l, f, p) {\n        const { startEdge: m, endEdge: g, direction: h } = t, x = n(r);\n        return {\n            groupSlides: function(n) {\n                return x ? function(n, t) {\n                    return u(n).filter((n)=>n % t == 0).map((e)=>n.slice(e, e + t));\n                }(n, r) : function(n) {\n                    return n.length ? u(n).reduce((t, r, u)=>{\n                        const x = s(t) || 0, y = 0 === x, v = r === a(n), b = c[m] - d[x][m], S = c[m] - d[r][g], w = !i && y ? h(l) : 0, E = o(S - (!i && v ? h(f) : 0) - (b + w));\n                        return u && E > e + p && t.push(r), v && t.push(n.length), t;\n                    }, []).map((t, e, r)=>{\n                        const o = Math.max(r[e - 1] || 0);\n                        return n.slice(o, t);\n                    }) : [];\n                }(n);\n            }\n        };\n    }\n    function P(n, e, r, f, p, m, P) {\n        const { align: z, axis: H, direction: k, startIndex: V, loop: B, duration: C, dragFree: N, dragThreshold: R, inViewThreshold: j, slidesToScroll: G, skipSnaps: q, containScroll: U, watchResize: W, watchSlides: $, watchDrag: Q, watchFocus: X } = m, Y = {\n            measure: function(n) {\n                const { offsetTop: t, offsetLeft: e, offsetWidth: r, offsetHeight: o } = n;\n                return {\n                    top: t,\n                    right: e + r,\n                    bottom: t + o,\n                    left: e,\n                    width: r,\n                    height: o\n                };\n            }\n        }, J = Y.measure(e), K = r.map(Y.measure), Z = function(n, t) {\n            const e = \"rtl\" === t, r = \"y\" === n, o = !r && e ? -1 : 1;\n            return {\n                scroll: r ? \"y\" : \"x\",\n                cross: r ? \"x\" : \"y\",\n                startEdge: r ? \"top\" : e ? \"right\" : \"left\",\n                endEdge: r ? \"bottom\" : e ? \"left\" : \"right\",\n                measureSize: function(n) {\n                    const { height: t, width: e } = n;\n                    return r ? t : e;\n                },\n                direction: function(n) {\n                    return n * o;\n                }\n            };\n        }(H, k), _ = Z.measureSize(J), nn = function(n) {\n            return {\n                measure: function(t) {\n                    return n * (t / 100);\n                }\n            };\n        }(_), tn = function(n, e) {\n            const r = {\n                start: function() {\n                    return 0;\n                },\n                center: function(n) {\n                    return o(n) / 2;\n                },\n                end: o\n            };\n            function o(n) {\n                return e - n;\n            }\n            return {\n                measure: function(o, i) {\n                    return t(n) ? r[n](o) : n(e, o, i);\n                }\n            };\n        }(z, _), en = !B && !!U, rn = B || !!U, { slideSizes: on, slideSizesWithGaps: cn, startGap: un, endGap: sn } = function(n, t, e, r, i, c) {\n            const { measureSize: u, startEdge: a, endEdge: l } = n, f = e[0] && i, p = function() {\n                if (!f) return 0;\n                const n = e[0];\n                return o(t[a] - n[a]);\n            }(), m = function() {\n                if (!f) return 0;\n                const n = c.getComputedStyle(s(r));\n                return parseFloat(n.getPropertyValue(`margin-${l}`));\n            }(), g = e.map(u), h = e.map((n, t, e)=>{\n                const r = !t, o = d(e, t);\n                return r ? g[t] + p : o ? g[t] + m : e[t + 1][a] - n[a];\n            }).map(o);\n            return {\n                slideSizes: g,\n                slideSizesWithGaps: h,\n                startGap: p,\n                endGap: m\n            };\n        }(Z, J, K, r, rn, p), an = O(Z, _, G, B, J, K, un, sn, 2), { snaps: dn, snapsAligned: ln } = function(n, t, e, r, i) {\n            const { startEdge: c, endEdge: u } = n, { groupSlides: a } = i, d = a(r).map((n)=>s(n)[u] - n[0][c]).map(o).map(t.measure), l = r.map((n)=>e[c] - n[c]).map((n)=>-o(n)), f = a(l).map((n)=>n[0]).map((n, t)=>n + d[t]);\n            return {\n                snaps: l,\n                snapsAligned: f\n            };\n        }(Z, tn, J, K, an), fn = -s(dn) + s(cn), { snapsContained: pn, scrollContainLimit: mn } = function(n, t, e, r, o) {\n            const i = x(-t + n, 0), u = e.map((n, t)=>{\n                const { min: r, max: o } = i, c = i.constrain(n), u = !t, s = d(e, t);\n                return u ? o : s || l(r, c) ? r : l(o, c) ? o : c;\n            }).map((n)=>parseFloat(n.toFixed(3))), a = function() {\n                const n = u[0], t = s(u);\n                return x(u.lastIndexOf(n), u.indexOf(t) + 1);\n            }();\n            function l(n, t) {\n                return c(n, t) < 1;\n            }\n            return {\n                snapsContained: function() {\n                    if (t <= n + o) return [\n                        i.max\n                    ];\n                    if (\"keepSnaps\" === r) return u;\n                    const { min: e, max: c } = a;\n                    return u.slice(e, c);\n                }(),\n                scrollContainLimit: a\n            };\n        }(_, fn, ln, U, 2), gn = en ? pn : ln, { limit: hn } = function(n, t, e) {\n            const r = t[0];\n            return {\n                limit: x(e ? r - n : s(t), r)\n            };\n        }(fn, gn, B), xn = y(a(gn), V, B), yn = xn.clone(), vn = u(r), bn = h(f, p, (n)=>(({ dragHandler: n, scrollBody: t, scrollBounds: e, options: { loop: r } }, o)=>{\n                r || e.constrain(n.pointerDown()), t.seek(o);\n            })(Hn, n), (n)=>(({ scrollBody: n, translate: t, location: e, offsetLocation: r, scrollLooper: o, slideLooper: i, dragHandler: c, animation: u, eventHandler: s, scrollBounds: a, options: { loop: d } }, l)=>{\n                const f = n.settled(), p = !a.shouldConstrain(), m = d ? f : f && p;\n                m && !c.pointerDown() && (u.stop(), s.emit(\"settle\")), m || s.emit(\"scroll\");\n                const g = e.get() * l + En.get() * (1 - l);\n                r.set(g), d && (o.loop(n.direction()), i.loop()), t.to(r.get());\n            })(Hn, n)), Sn = gn[xn.get()], wn = I(Sn), En = I(Sn), Ln = I(Sn), Dn = I(Sn), In = function(n, t, e, r, c, u) {\n            let s = 0, a = 0, d = c, l = u, f = n.get(), p = 0;\n            function m(n) {\n                return d = n, h;\n            }\n            function g(n) {\n                return l = n, h;\n            }\n            const h = {\n                direction: function() {\n                    return a;\n                },\n                duration: function() {\n                    return d;\n                },\n                velocity: function() {\n                    return s;\n                },\n                seek: function(t) {\n                    const o = t / 1e3, c = d * o, u = r.get() - n.get();\n                    let m = 0;\n                    return d ? (e.set(n), s += u / c, s *= l, f += s, n.add(s * o), m = f - p) : (s = 0, e.set(r), n.set(r), m = u), a = i(m), p = f, h;\n                },\n                settled: function() {\n                    return o(r.get() - t.get()) < .001;\n                },\n                useBaseFriction: function() {\n                    return g(u);\n                },\n                useBaseDuration: function() {\n                    return m(c);\n                },\n                useFriction: g,\n                useDuration: m\n            };\n            return h;\n        }(wn, Ln, En, Dn, C, .68), An = L(B, gn, fn, hn, Dn), Fn = function(n, t, e, r, o, i, c) {\n            function u(o) {\n                const u = o.distance, s = o.index !== t.get();\n                i.add(u), u && (r.duration() ? n.start() : (n.update(), n.render(1), n.update())), s && (e.set(t.get()), t.set(o.index), c.emit(\"select\"));\n            }\n            return {\n                distance: function(n, t) {\n                    u(o.byDistance(n, t));\n                },\n                index: function(n, e) {\n                    const r = t.clone().set(n);\n                    u(o.byIndex(r.get(), e));\n                }\n            };\n        }(bn, xn, yn, In, An, Dn, P), Mn = function(n) {\n            const { max: t, length: e } = n;\n            return {\n                get: function(n) {\n                    return e ? (n - t) / -e : 0;\n                }\n            };\n        }(hn), Tn = g(), On = T(e, r, P, j), { slideRegistry: Pn } = function(n, t, e, r, o, i) {\n            const { groupSlides: c } = o, { min: u, max: f } = r;\n            return {\n                slideRegistry: function() {\n                    const r = c(i), o = !n || \"keepSnaps\" === t;\n                    return 1 === e.length ? [\n                        i\n                    ] : o ? r : r.slice(u, f).map((n, t, e)=>{\n                        const r = !t, o = d(e, t);\n                        return r ? l(s(e[0]) + 1) : o ? l(a(i) - s(e)[0] + 1, s(e)[0]) : n;\n                    });\n                }()\n            };\n        }(en, U, gn, mn, an, vn), zn = D(n, r, Pn, Fn, In, Tn, P, X), Hn = {\n            ownerDocument: f,\n            ownerWindow: p,\n            eventHandler: P,\n            containerRect: J,\n            slideRects: K,\n            animation: bn,\n            axis: Z,\n            dragHandler: v(Z, n, f, p, Dn, b(Z, p), wn, bn, Fn, In, An, xn, P, nn, N, R, q, .68, Q),\n            eventStore: Tn,\n            percentOfView: nn,\n            index: xn,\n            indexPrevious: yn,\n            limit: hn,\n            location: wn,\n            offsetLocation: Ln,\n            previousLocation: En,\n            options: m,\n            resizeHandler: S(e, P, p, r, Z, W, Y),\n            scrollBody: In,\n            scrollBounds: w(hn, Ln, Dn, In, nn),\n            scrollLooper: E(fn, hn, Ln, [\n                wn,\n                Ln,\n                En,\n                Dn\n            ]),\n            scrollProgress: Mn,\n            scrollSnapList: gn.map(Mn.get),\n            scrollSnaps: gn,\n            scrollTarget: An,\n            scrollTo: Fn,\n            slideLooper: F(Z, _, fn, on, cn, dn, gn, Ln, r),\n            slideFocus: zn,\n            slidesHandler: M(e, P, $),\n            slidesInView: On,\n            slideIndexes: vn,\n            slideRegistry: Pn,\n            slidesToScroll: an,\n            target: Dn,\n            translate: A(Z, e)\n        };\n        return Hn;\n    }\n    const z = {\n        align: \"center\",\n        axis: \"x\",\n        container: null,\n        slides: null,\n        containScroll: \"trimSnaps\",\n        direction: \"ltr\",\n        slidesToScroll: 1,\n        inViewThreshold: 0,\n        breakpoints: {},\n        dragFree: !1,\n        dragThreshold: 10,\n        loop: !1,\n        skipSnaps: !1,\n        duration: 25,\n        startIndex: 0,\n        active: !0,\n        watchDrag: !0,\n        watchResize: !0,\n        watchSlides: !0,\n        watchFocus: !0\n    };\n    function H(n) {\n        function t(n, t) {\n            return p(n, t || {});\n        }\n        const e = {\n            mergeOptions: t,\n            optionsAtMedia: function(e) {\n                const r = e.breakpoints || {}, o = f(r).filter((t)=>n.matchMedia(t).matches).map((n)=>r[n]).reduce((n, e)=>t(n, e), {});\n                return t(e, o);\n            },\n            optionsMediaQueries: function(t) {\n                return t.map((n)=>f(n.breakpoints || {})).reduce((n, t)=>n.concat(t), []).map(n.matchMedia);\n            }\n        };\n        return e;\n    }\n    function k(n, e, r) {\n        const o = n.ownerDocument, i = o.defaultView, c = H(i), u = function(n) {\n            let t = [];\n            return {\n                init: function(e, r) {\n                    return t = r.filter(({ options: t })=>!1 !== n.optionsAtMedia(t).active), t.forEach((t)=>t.init(e, n)), r.reduce((n, t)=>Object.assign(n, {\n                            [t.name]: t\n                        }), {});\n                },\n                destroy: function() {\n                    t = t.filter((n)=>n.destroy());\n                }\n            };\n        }(c), s = g(), a = function() {\n            let n, t = {};\n            function e(n) {\n                return t[n] || [];\n            }\n            const r = {\n                init: function(t) {\n                    n = t;\n                },\n                emit: function(t) {\n                    return e(t).forEach((e)=>e(n, t)), r;\n                },\n                off: function(n, o) {\n                    return t[n] = e(n).filter((n)=>n !== o), r;\n                },\n                on: function(n, o) {\n                    return t[n] = e(n).concat([\n                        o\n                    ]), r;\n                },\n                clear: function() {\n                    t = {};\n                }\n            };\n            return r;\n        }(), { mergeOptions: d, optionsAtMedia: l, optionsMediaQueries: f } = c, { on: p, off: m, emit: h } = a, x = F;\n        let y, v, b, S, w = !1, E = d(z, k.globalOptions), L = d(E), D = [];\n        function I(t) {\n            const e = P(n, b, S, o, i, t, a);\n            if (t.loop && !e.slideLooper.canLoop()) return I(Object.assign({}, t, {\n                loop: !1\n            }));\n            return e;\n        }\n        function A(e, r) {\n            w || (E = d(E, e), L = l(E), D = r || D, function() {\n                const { container: e, slides: r } = L, o = t(e) ? n.querySelector(e) : e;\n                b = o || n.children[0];\n                const i = t(r) ? b.querySelectorAll(r) : r;\n                S = [].slice.call(i || b.children);\n            }(), y = I(L), f([\n                E,\n                ...D.map(({ options: n })=>n)\n            ]).forEach((n)=>s.add(n, \"change\", F)), L.active && (y.translate.to(y.location.get()), y.animation.init(), y.slidesInView.init(), y.slideFocus.init(V), y.eventHandler.init(V), y.resizeHandler.init(V), y.slidesHandler.init(V), y.options.loop && y.slideLooper.loop(), b.offsetParent && S.length && y.dragHandler.init(V), v = u.init(V, D)));\n        }\n        function F(n, t) {\n            const e = O();\n            M(), A(d({\n                startIndex: e\n            }, n), t), a.emit(\"reInit\");\n        }\n        function M() {\n            y.dragHandler.destroy(), y.eventStore.clear(), y.translate.clear(), y.slideLooper.clear(), y.resizeHandler.destroy(), y.slidesHandler.destroy(), y.slidesInView.destroy(), y.animation.destroy(), u.destroy(), s.clear();\n        }\n        function T(n, t, e) {\n            L.active && !w && (y.scrollBody.useBaseFriction().useDuration(!0 === t ? 0 : L.duration), y.scrollTo.index(n, e || 0));\n        }\n        function O() {\n            return y.index.get();\n        }\n        const V = {\n            canScrollNext: function() {\n                return y.index.add(1).get() !== O();\n            },\n            canScrollPrev: function() {\n                return y.index.add(-1).get() !== O();\n            },\n            containerNode: function() {\n                return b;\n            },\n            internalEngine: function() {\n                return y;\n            },\n            destroy: function() {\n                w || (w = !0, s.clear(), M(), a.emit(\"destroy\"), a.clear());\n            },\n            off: m,\n            on: p,\n            emit: h,\n            plugins: function() {\n                return v;\n            },\n            previousScrollSnap: function() {\n                return y.indexPrevious.get();\n            },\n            reInit: x,\n            rootNode: function() {\n                return n;\n            },\n            scrollNext: function(n) {\n                T(y.index.add(1).get(), n, -1);\n            },\n            scrollPrev: function(n) {\n                T(y.index.add(-1).get(), n, 1);\n            },\n            scrollProgress: function() {\n                return y.scrollProgress.get(y.location.get());\n            },\n            scrollSnapList: function() {\n                return y.scrollSnapList;\n            },\n            scrollTo: T,\n            selectedScrollSnap: O,\n            slideNodes: function() {\n                return S;\n            },\n            slidesInView: function() {\n                return y.slidesInView.get();\n            },\n            slidesNotInView: function() {\n                return y.slidesInView.get(!1);\n            }\n        };\n        return A(e, r), setTimeout(()=>a.emit(\"init\"), 0), V;\n    }\n    return k.globalOptions = void 0, k;\n});\n// wheel-gestures\n!function(e, t) {\n    $c680b46bbc90729e$exports = t();\n}($c680b46bbc90729e$exports, function() {\n    \"use strict\";\n    function e() {\n        return (e = Object.assign || function(e) {\n            for(var t = 1; t < arguments.length; t++){\n                var n = arguments[t];\n                for(var i in n)Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);\n            }\n            return e;\n        }).apply(this, arguments);\n    }\n    function t(e, t) {\n        if (e.length !== t.length) throw new Error(\"vectors must be same length\");\n        return e.map(function(e, n) {\n            return e + t[n];\n        });\n    }\n    function n(e) {\n        return Math.max.apply(Math, e.map(Math.abs));\n    }\n    function i(e) {\n        return Object.freeze(e), Object.values(e).forEach(function(e) {\n            null === e || \"object\" != typeof e || Object.isFrozen(e) || i(e);\n        }), e;\n    }\n    var o = [\n        1,\n        18,\n        \"undefined\" != typeof window && window.innerHeight || 800\n    ], r = [\n        -1,\n        -1,\n        -1\n    ], a = i({\n        preventWheelAction: !0,\n        reverseSign: [\n            !0,\n            !0,\n            !1\n        ]\n    }), s = {\n        active: !0,\n        breakpoints: {},\n        wheelDraggingClass: \"is-wheel-dragging\",\n        forceWheelAxis: void 0,\n        target: void 0\n    };\n    function u(c) {\n        var l;\n        void 0 === c && (c = {});\n        var m = function() {};\n        return {\n            name: \"wheelGestures\",\n            options: c,\n            init: function(f, d) {\n                var v, h, p = d.mergeOptions, M = d.optionsAtMedia, g = p(s, u.globalOptions), x = p(g, c);\n                l = M(x);\n                var b, E = f.internalEngine(), w = null != (v = l.target) ? v : f.containerNode().parentNode, y = null != (h = l.forceWheelAxis) ? h : E.options.axis, S = function(s) {\n                    void 0 === s && (s = {});\n                    var u, c, l, m = function() {\n                        var e = {};\n                        function t(t, n) {\n                            e[t] = (e[t] || []).filter(function(e) {\n                                return e !== n;\n                            });\n                        }\n                        return i({\n                            on: function(n, i) {\n                                return e[n] = (e[n] || []).concat(i), function() {\n                                    return t(n, i);\n                                };\n                            },\n                            off: t,\n                            dispatch: function(t, n) {\n                                t in e && e[t].forEach(function(e) {\n                                    return e(n);\n                                });\n                            }\n                        });\n                    }(), f = m.on, d = m.off, v = m.dispatch, h = a, p = {\n                        isStarted: !1,\n                        isStartPublished: !1,\n                        isMomentum: !1,\n                        startTime: 0,\n                        lastAbsDelta: Infinity,\n                        axisMovement: [\n                            0,\n                            0,\n                            0\n                        ],\n                        axisVelocity: [\n                            0,\n                            0,\n                            0\n                        ],\n                        accelerationFactors: [],\n                        scrollPoints: [],\n                        scrollPointsToMerge: [],\n                        willEndTimeout: 400\n                    }, M = !1, g = function(e) {\n                        Array.isArray(e) ? e.forEach(function(e) {\n                            return E(e);\n                        }) : E(e);\n                    }, x = function(t) {\n                        return void 0 === t && (t = {}), Object.values(t).some(function(e) {\n                            return null == e;\n                        }) ? h : h = i(e({}, a, h, t));\n                    }, b = function(n) {\n                        var i = e({\n                            event: u,\n                            isStart: !1,\n                            isEnding: !1,\n                            isMomentumCancel: !1,\n                            isMomentum: p.isMomentum,\n                            axisDelta: [\n                                0,\n                                0,\n                                0\n                            ],\n                            axisVelocity: p.axisVelocity,\n                            axisMovement: p.axisMovement,\n                            get axisMovementProjection () {\n                                return t(i.axisMovement, i.axisVelocity.map(function(e) {\n                                    var t;\n                                    return void 0 === t && (t = .996), e * t / (1 - t);\n                                }));\n                            }\n                        }, n);\n                        v(\"wheel\", e({}, i, {\n                            previous: c\n                        })), c = i;\n                    }, E = function(i) {\n                        var a, s = function(t) {\n                            return e({}, t, {\n                                axisDelta: t.axisDelta.map(function(e) {\n                                    return Math.min(Math.max(-700, e), 700);\n                                })\n                            });\n                        }(function(t, n) {\n                            if (!n) return t;\n                            var i = !0 === n ? r : n.map(function(e) {\n                                return e ? -1 : 1;\n                            });\n                            return e({}, t, {\n                                axisDelta: t.axisDelta.map(function(e, t) {\n                                    return e * i[t];\n                                })\n                            });\n                        }({\n                            timeStamp: (a = i).timeStamp,\n                            axisDelta: [\n                                a.deltaX * o[a.deltaMode],\n                                a.deltaY * o[a.deltaMode],\n                                (a.deltaZ || 0) * o[a.deltaMode]\n                            ]\n                        }, h.reverseSign)), c = s.axisDelta, l = s.timeStamp, m = n(c);\n                        i.preventDefault && function(e, t) {\n                            var n = h.preventWheelAction, i = t[0], o = t[1], r = t[2];\n                            if (\"boolean\" == typeof n) return n;\n                            switch(n){\n                                case \"x\":\n                                    return Math.abs(i) >= e;\n                                case \"y\":\n                                    return Math.abs(o) >= e;\n                                case \"z\":\n                                    return Math.abs(r) >= e;\n                                default:\n                                    return !1;\n                            }\n                        }(m, c) && i.preventDefault(), p.isStarted ? p.isMomentum && m > Math.max(2, 2 * p.lastAbsDelta) && (L(!0), A()) : A(), 0 === m && Object.is && Object.is(i.deltaX, -0) ? M = !0 : (u = i, p.axisMovement = t(p.axisMovement, c), p.lastAbsDelta = m, p.scrollPointsToMerge.push({\n                            axisDelta: c,\n                            timeStamp: l\n                        }), w(), b({\n                            axisDelta: c,\n                            isStart: !p.isStartPublished\n                        }), p.isStartPublished = !0, j());\n                    }, w = function() {\n                        var e;\n                        2 === p.scrollPointsToMerge.length ? (p.scrollPoints.unshift({\n                            axisDeltaSum: p.scrollPointsToMerge.map(function(e) {\n                                return e.axisDelta;\n                            }).reduce(t),\n                            timeStamp: (e = p.scrollPointsToMerge.map(function(e) {\n                                return e.timeStamp;\n                            }), e.reduce(function(e, t) {\n                                return e + t;\n                            }) / e.length)\n                        }), S(), p.scrollPointsToMerge.length = 0, p.scrollPoints.length = 1, p.isMomentum || T()) : p.isStartPublished || y();\n                    }, y = function() {\n                        var e;\n                        p.axisVelocity = (e = p.scrollPointsToMerge, e[e.length - 1]).axisDelta.map(function(e) {\n                            return e / p.willEndTimeout;\n                        });\n                    }, S = function() {\n                        var e = p.scrollPoints, t = e[0], n = e[1];\n                        if (n && t) {\n                            var i = t.timeStamp - n.timeStamp;\n                            if (!(i <= 0)) {\n                                var o = t.axisDeltaSum.map(function(e) {\n                                    return e / i;\n                                }), r = o.map(function(e, t) {\n                                    return e / (p.axisVelocity[t] || 1);\n                                });\n                                p.axisVelocity = o, p.accelerationFactors.push(r), D(i);\n                            }\n                        }\n                    }, D = function(e) {\n                        var t = 10 * Math.ceil(e / 10) * 1.2;\n                        p.isMomentum || (t = Math.max(100, 2 * t)), p.willEndTimeout = Math.min(1e3, Math.round(t));\n                    }, P = function(e) {\n                        return 0 === e || e <= .96 && e >= .6;\n                    }, T = function() {\n                        if (p.accelerationFactors.length >= 5) {\n                            if (M && (M = !1, n(p.axisVelocity) >= .2)) return void O();\n                            var e = p.accelerationFactors.slice(-5);\n                            e.every(function(e) {\n                                var t = !!e.reduce(function(e, t) {\n                                    return e && e < 1 && e === t ? 1 : 0;\n                                }), n = e.filter(P).length === e.length;\n                                return t || n;\n                            }) && O(), p.accelerationFactors = e;\n                        }\n                    }, O = function() {\n                        p.isMomentum = !0;\n                    }, A = function() {\n                        (p = {\n                            isStarted: !1,\n                            isStartPublished: !1,\n                            isMomentum: !1,\n                            startTime: 0,\n                            lastAbsDelta: Infinity,\n                            axisMovement: [\n                                0,\n                                0,\n                                0\n                            ],\n                            axisVelocity: [\n                                0,\n                                0,\n                                0\n                            ],\n                            accelerationFactors: [],\n                            scrollPoints: [],\n                            scrollPointsToMerge: [],\n                            willEndTimeout: 400\n                        }).isStarted = !0, p.startTime = Date.now(), c = void 0, M = !1;\n                    }, j = function() {\n                        clearTimeout(l), l = setTimeout(L, p.willEndTimeout);\n                    }, L = function(e) {\n                        void 0 === e && (e = !1), p.isStarted && (b(p.isMomentum && e ? {\n                            isEnding: !0,\n                            isMomentumCancel: !0\n                        } : {\n                            isEnding: !0\n                        }), p.isMomentum = !1, p.isStarted = !1);\n                    }, V = function(e) {\n                        var t = [], n = function(n) {\n                            n.removeEventListener(\"wheel\", e), t = t.filter(function(e) {\n                                return e !== n;\n                            });\n                        };\n                        return i({\n                            observe: function(i) {\n                                return i.addEventListener(\"wheel\", e, {\n                                    passive: !1\n                                }), t.push(i), function() {\n                                    return n(i);\n                                };\n                            },\n                            unobserve: n,\n                            disconnect: function() {\n                                t.forEach(n);\n                            }\n                        });\n                    }(g), C = V.observe, F = V.unobserve, W = V.disconnect;\n                    return x(s), i({\n                        on: f,\n                        off: d,\n                        observe: C,\n                        unobserve: F,\n                        disconnect: W,\n                        feedWheel: g,\n                        updateOptions: x\n                    });\n                }({\n                    preventWheelAction: y,\n                    reverseSign: [\n                        !0,\n                        !0,\n                        !1\n                    ]\n                }), D = S.observe(w), P = S.on(\"wheel\", function(e) {\n                    var t = e.axisDelta, n = t[0], i = t[1], o = \"x\" === y ? i : n, r = e.isEnding && !e.isMomentum || e.isMomentum && e.previous && !e.previous.isMomentum;\n                    Math.abs(\"x\" === y ? n : i) > Math.abs(o) && !T && !e.isMomentum && function(e) {\n                        try {\n                            L(b = new MouseEvent(\"mousedown\", e.event));\n                        } catch (e) {\n                            return m();\n                        }\n                        T = !0, document.documentElement.addEventListener(\"mousemove\", A, !0), document.documentElement.addEventListener(\"mouseup\", A, !0), document.documentElement.addEventListener(\"mousedown\", A, !0), l.wheelDraggingClass && w.classList.add(l.wheelDraggingClass);\n                    }(e), T && (r ? function(e) {\n                        T = !1, L(j(\"mouseup\", e)), O(), l.wheelDraggingClass && w.classList.remove(l.wheelDraggingClass);\n                    }(e) : L(j(\"mousemove\", e)));\n                }), T = !1;\n                function O() {\n                    document.documentElement.removeEventListener(\"mousemove\", A, !0), document.documentElement.removeEventListener(\"mouseup\", A, !0), document.documentElement.removeEventListener(\"mousedown\", A, !0);\n                }\n                function A(e) {\n                    T && e.isTrusted && e.stopImmediatePropagation();\n                }\n                function j(e, t) {\n                    var n, i;\n                    if (y === E.options.axis) {\n                        var o = t.axisMovement;\n                        n = o[0], i = o[1];\n                    } else {\n                        var r = t.axisMovement;\n                        i = r[0], n = r[1];\n                    }\n                    if (!E.options.skipSnaps && !E.options.dragFree) {\n                        var a = E.containerRect.width, s = E.containerRect.height;\n                        n = n < 0 ? Math.max(n, -a) : Math.min(n, a), i = i < 0 ? Math.max(i, -s) : Math.min(i, s);\n                    }\n                    return new MouseEvent(e, {\n                        clientX: b.clientX + n,\n                        clientY: b.clientY + i,\n                        screenX: b.screenX + n,\n                        screenY: b.screenY + i,\n                        movementX: n,\n                        movementY: i,\n                        button: 0,\n                        bubbles: !0,\n                        cancelable: !0,\n                        composed: !0\n                    });\n                }\n                function L(e) {\n                    f.containerNode().dispatchEvent(e);\n                }\n                m = function() {\n                    D(), P(), O();\n                };\n            },\n            destroy: function() {\n                return m();\n            }\n        };\n    }\n    return u.globalOptions = void 0, u;\n});\n//# sourceMappingURL=embla-carousel-wheel-gestures.umd.js.map\n// fade\n!function(n, t) {\n    $c680b46bbc90729e$exports = t();\n}($c680b46bbc90729e$exports, function() {\n    \"use strict\";\n    function n(n, t, e) {\n        return Math.min(Math.max(n, t), e);\n    }\n    function t(n) {\n        return \"number\" == typeof n && !isNaN(n);\n    }\n    function e(e = {}) {\n        const o = 1, i = 0, r = .68, s = 1e3 / 60;\n        let l, c, a, f, d = [], u = 0, p = 0, g = 0, y = !1;\n        function E() {\n            v(l.selectedScrollSnap(), o);\n        }\n        function S() {\n            y = !1;\n        }\n        function h() {\n            y = !1, u = 0, p = 0;\n        }\n        function m() {\n            const n = l.internalEngine().scrollBody.duration();\n            p = n ? 0 : o, y = !0, n || E();\n        }\n        function b(n) {\n            const { scrollSnaps: e, location: o, target: i } = l.internalEngine();\n            !t(n) || d[n] < .5 || (o.set(e[n]), i.set(o));\n        }\n        function v(t, e) {\n            l.scrollSnapList().forEach((r, s)=>{\n                const c = Math.abs(e), a = d[s], f = s === t, p = n(f ? a + c : a - c, i, o);\n                d[s] = p;\n                const E = f && y, S = l.previousScrollSnap();\n                E && (d[S] = 1 - p), f && function(n, t) {\n                    const { index: e, dragHandler: o, scrollSnaps: i } = l.internalEngine(), r = o.pointerDown(), s = 1 / (i.length - 1);\n                    let c = n, a = r ? l.selectedScrollSnap() : l.previousScrollSnap();\n                    if (r && c === a) {\n                        const n = -1 * Math.sign(u);\n                        c = a, a = e.clone().set(a).add(n).get();\n                    }\n                    const f = a * s, d = (c - a) * s;\n                    g = f + d * t;\n                }(t, p), function(n) {\n                    const t = l.internalEngine().slideRegistry[n], { scrollSnaps: e, containerRect: o } = l.internalEngine(), r = d[n];\n                    t.forEach((t)=>{\n                        const s = l.slideNodes()[t].style, c = parseFloat(r.toFixed(2)), a = c > i, f = function(n) {\n                            const { axis: t } = l.internalEngine();\n                            return `translate${t.scroll.toUpperCase()}(${t.direction(n)}px)`;\n                        }(a ? e[n] : o.width + 2);\n                        a && (s.transform = f), s.opacity = c.toString(), s.pointerEvents = r > .5 ? \"auto\" : \"none\", a || (s.transform = f);\n                    });\n                }(s);\n            });\n        }\n        function x() {\n            const { dragHandler: n, index: t, scrollBody: e } = l.internalEngine(), o = l.selectedScrollSnap();\n            if (!n.pointerDown()) return o;\n            const i = Math.sign(e.velocity()), r = Math.sign(u), s = t.clone().set(o).add(-1 * i).get();\n            return i && r ? r === i ? s : o : null;\n        }\n        function M() {\n            const { target: n, location: e } = l.internalEngine(), i = n.get() - e.get(), a = Math.abs(i) >= 1, f = x(), g = !t(f);\n            return function(n) {\n                const { dragHandler: e, scrollBody: i } = n.internalEngine(), l = s / 1e3, a = e.pointerDown(), f = i.velocity() * l, g = i.duration(), y = x(), E = !t(y);\n                if (a) {\n                    if (!f) return;\n                    u += f, p = Math.abs(f / c), b(y);\n                }\n                if (!a) {\n                    if (!g || E) return;\n                    p += (o - d[y]) / g, p *= r;\n                }\n                E || v(y, p);\n            }(l), !g && !a && d[f] > .999;\n        }\n        function w() {\n            return g;\n        }\n        return {\n            name: \"fade\",\n            options: e,\n            init: function(t) {\n                l = t;\n                const e = l.selectedScrollSnap(), { scrollBody: r, containerRect: s, axis: u } = l.internalEngine(), p = u.measureSize(s);\n                c = n(.75 * p, 200, 500), y = !1, d = l.scrollSnapList().map((n, t)=>t === e ? o : i), a = r.settled, f = l.scrollProgress, r.settled = M, l.scrollProgress = w, l.on(\"select\", m).on(\"slideFocus\", E).on(\"pointerDown\", h).on(\"pointerUp\", S), function() {\n                    const { translate: n, slideLooper: t } = l.internalEngine();\n                    n.clear(), n.toggleActive(!1), t.loopPoints.forEach(({ translate: n })=>{\n                        n.clear(), n.toggleActive(!1);\n                    });\n                }(), E();\n            },\n            destroy: function() {\n                const { scrollBody: n } = l.internalEngine();\n                n.settled = a, l.scrollProgress = f, l.off(\"select\", m).off(\"slideFocus\", E).off(\"pointerDown\", h).off(\"pointerUp\", S), l.slideNodes().forEach((n)=>{\n                    const t = n.style;\n                    t.opacity = \"\", t.transform = \"\", t.pointerEvents = \"\", n.getAttribute(\"style\") || n.removeAttribute(\"style\");\n                });\n            }\n        };\n    }\n    return e.globalOptions = void 0, e;\n});\n// class-names\n!function(n, e) {\n    $c680b46bbc90729e$exports = e();\n}($c680b46bbc90729e$exports, function() {\n    \"use strict\";\n    const n = {\n        active: !0,\n        breakpoints: {},\n        snapped: \"is-snapped\",\n        inView: \"is-in-view\",\n        draggable: \"is-draggable\",\n        dragging: \"is-dragging\"\n    };\n    function e(n, e) {\n        if (!n || !e) return;\n        const { classList: o } = n;\n        o.contains(e) && o.remove(e);\n    }\n    function o(n, e) {\n        if (!n || !e) return;\n        const { classList: o } = n;\n        o.contains(e) || o.add(e);\n    }\n    function i(t = {}) {\n        let s, a, r, c;\n        const f = [\n            \"select\"\n        ], d = [\n            \"pointerDown\",\n            \"pointerUp\"\n        ], l = [\n            \"slidesInView\"\n        ];\n        function g(n, i) {\n            \"pointerDown\" === i ? o(r, s.dragging) : e(r, s.dragging);\n        }\n        function p(n, i) {\n            const t = a.containerNode().querySelectorAll(`.${i}`);\n            var s;\n            (s = t, Array.from(s)).forEach((n)=>e(n, i)), n.forEach((n)=>o(c[n], i));\n        }\n        function u() {\n            const { slideRegistry: n } = a.internalEngine();\n            p(n[a.selectedScrollSnap()], s.snapped);\n        }\n        function h() {\n            p(a.slidesInView(), s.inView);\n        }\n        return {\n            name: \"classNames\",\n            options: t,\n            init: function(e, p) {\n                a = e;\n                const { mergeOptions: E, optionsAtMedia: b } = p, m = E(n, i.globalOptions), w = E(m, t);\n                s = b(w), r = a.rootNode(), c = a.slideNodes(), !!a.internalEngine().options.watchDrag && o(r, s.draggable), s.dragging && d.forEach((n)=>a.on(n, g)), s.snapped && (f.forEach((n)=>a.on(n, u)), u()), s.inView && (l.forEach((n)=>a.on(n, h)), h());\n            },\n            destroy: function() {\n                e(r, s.draggable), d.forEach((n)=>a.off(n, g)), f.forEach((n)=>a.off(n, u)), l.forEach((n)=>a.off(n, h)), c.forEach((n)=>e(n, s.snapped));\n            }\n        };\n    }\n    return i.globalOptions = void 0, i;\n});\n// autoplay\n!function(n, t) {\n    $c680b46bbc90729e$exports = t();\n}($c680b46bbc90729e$exports, function() {\n    \"use strict\";\n    const n = {\n        active: !0,\n        breakpoints: {},\n        delay: 4e3,\n        jump: !1,\n        playOnInit: !0,\n        stopOnFocusIn: !0,\n        stopOnInteraction: !0,\n        stopOnMouseEnter: !1,\n        stopOnLastSnap: !1,\n        rootNode: null\n    };\n    function t(o = {}) {\n        let e, i, r, a = !1, s = !0, l = !1, u = 0;\n        function c() {\n            if (r) return;\n            if (!s) return;\n            a || i.emit(\"autoplay:play\");\n            const { ownerWindow: n } = i.internalEngine();\n            n.clearInterval(u), u = n.setInterval(g, e.delay), a = !0;\n        }\n        function p() {\n            if (r) return;\n            a && i.emit(\"autoplay:stop\");\n            const { ownerWindow: n } = i.internalEngine();\n            n.clearInterval(u), u = 0, a = !1;\n        }\n        function d() {\n            if (f()) return s = a, p();\n            s && c();\n        }\n        function f() {\n            const { ownerDocument: n } = i.internalEngine();\n            return \"hidden\" === n.visibilityState;\n        }\n        function y(n) {\n            void 0 !== n && (l = n), s = !0, c();\n        }\n        function g() {\n            const { index: n } = i.internalEngine(), t = n.clone().add(1).get(), o = i.scrollSnapList().length - 1;\n            e.stopOnLastSnap && t === o && p(), i.canScrollNext() ? i.scrollNext(l) : i.scrollTo(0, l);\n        }\n        return {\n            name: \"autoplay\",\n            options: o,\n            init: function(a, u) {\n                i = a;\n                const { mergeOptions: y, optionsAtMedia: g } = u, O = y(n, t.globalOptions), m = y(O, o);\n                if (e = g(m), i.scrollSnapList().length <= 1) return;\n                l = e.jump, r = !1;\n                const { eventStore: I, ownerDocument: v } = i.internalEngine(), b = i.rootNode(), w = e.rootNode && e.rootNode(b) || b, E = i.containerNode();\n                i.on(\"pointerDown\", p), e.stopOnInteraction || i.on(\"pointerUp\", c), e.stopOnMouseEnter && (I.add(w, \"mouseenter\", ()=>{\n                    s = !1, p();\n                }), e.stopOnInteraction || I.add(w, \"mouseleave\", ()=>{\n                    s = !0, c();\n                })), e.stopOnFocusIn && (I.add(E, \"focusin\", p), e.stopOnInteraction || I.add(E, \"focusout\", c)), I.add(v, \"visibilitychange\", d), e.playOnInit && !f() && c();\n            },\n            destroy: function() {\n                i.off(\"pointerDown\", p).off(\"pointerUp\", c), p(), r = !0, a = !1;\n            },\n            play: y,\n            stop: function() {\n                a && p();\n            },\n            reset: function() {\n                a && y();\n            },\n            isPlaying: function() {\n                return a;\n            }\n        };\n    }\n    return t.globalOptions = void 0, t;\n});\n// auto scroll\n!function(t, o) {\n    $c680b46bbc90729e$exports = o();\n}($c680b46bbc90729e$exports, function() {\n    \"use strict\";\n    const t = {\n        direction: \"forward\",\n        speed: 2,\n        startDelay: 1e3,\n        active: !0,\n        breakpoints: {},\n        playOnInit: !0,\n        stopOnFocusIn: !0,\n        stopOnInteraction: !0,\n        stopOnMouseEnter: !1,\n        rootNode: null\n    };\n    function o(n = {}) {\n        let e, i, r, s, c, l = !1, a = !0, u = 0;\n        function d() {\n            if (r || l) return;\n            if (!a) return;\n            i.emit(\"autoScroll:play\");\n            const t = i.internalEngine(), { ownerWindow: o } = t;\n            u = o.setTimeout(()=>{\n                t.scrollBody = function(t) {\n                    const { location: o, previousLocation: n, offsetLocation: r, target: s, scrollTarget: c, index: l, indexPrevious: a, limit: { reachedMin: u, reachedMax: d, constrain: p }, options: { loop: g } } = t, y = \"forward\" === e.direction ? -1 : 1, m = ()=>h;\n                    let O = 0, w = 0, b = o.get(), v = 0, I = !1;\n                    function S(t) {\n                        const m = t / 1e3;\n                        let S = 0;\n                        n.set(o), O = y * e.speed * 55, b += O, o.add(O * m), s.set(o), S = b - v, w = Math.sign(S), v = b;\n                        const D = c.byDistance(0, !1).index;\n                        l.get() !== D && (a.set(l.get()), l.set(D), i.emit(\"select\"));\n                        const E = \"forward\" === e.direction ? u(r.get()) : d(r.get());\n                        if (!g && E) {\n                            I = !0;\n                            const t = p(o.get());\n                            o.set(t), s.set(o), f();\n                        }\n                        return h;\n                    }\n                    const h = {\n                        direction: ()=>w,\n                        duration: ()=>-1,\n                        velocity: ()=>O,\n                        settled: ()=>I,\n                        seek: S,\n                        useBaseFriction: m,\n                        useBaseDuration: m,\n                        useFriction: m,\n                        useDuration: m\n                    };\n                    return h;\n                }(t), t.animation.start();\n            }, s), l = !0;\n        }\n        function f() {\n            if (r || !l) return;\n            i.emit(\"autoScroll:stop\");\n            const t = i.internalEngine(), { ownerWindow: o } = t;\n            t.scrollBody = c, o.clearTimeout(u), u = 0, l = !1;\n        }\n        function p() {\n            a && d(), i.off(\"settle\", p);\n        }\n        function g() {\n            i.on(\"settle\", p);\n        }\n        return {\n            name: \"autoScroll\",\n            options: n,\n            init: function(l, u) {\n                i = l;\n                const { mergeOptions: p, optionsAtMedia: y } = u, m = p(t, o.globalOptions), O = p(m, n);\n                if (e = y(O), i.scrollSnapList().length <= 1) return;\n                s = e.startDelay, r = !1, c = i.internalEngine().scrollBody;\n                const { eventStore: w } = i.internalEngine(), b = i.rootNode(), v = e.rootNode && e.rootNode(b) || b, I = i.containerNode();\n                i.on(\"pointerDown\", f), e.stopOnInteraction || i.on(\"pointerUp\", g), e.stopOnMouseEnter && (w.add(v, \"mouseenter\", ()=>{\n                    a = !1, f();\n                }), e.stopOnInteraction || w.add(v, \"mouseleave\", ()=>{\n                    a = !0, d();\n                })), e.stopOnFocusIn && (w.add(I, \"focusin\", ()=>{\n                    f(), i.scrollTo(i.selectedScrollSnap(), !0);\n                }), e.stopOnInteraction || w.add(I, \"focusout\", d)), e.playOnInit && d();\n            },\n            destroy: function() {\n                i.off(\"pointerDown\", f).off(\"pointerUp\", g).off(\"settle\", p), f(), r = !0, l = !1;\n            },\n            play: function(t) {\n                void 0 !== t && (s = t), a = !0, d();\n            },\n            stop: function() {\n                l && f();\n            },\n            reset: function() {\n                l && (f(), g());\n            },\n            isPlaying: function() {\n                return l;\n            }\n        };\n    }\n    return o.globalOptions = void 0, o;\n});\n// auto-height\n!function(e, t) {\n    $c680b46bbc90729e$exports = t();\n}($c680b46bbc90729e$exports, function() {\n    \"use strict\";\n    function e(e = {}) {\n        let t, n = [];\n        const o = [\n            \"select\",\n            \"slideFocus\"\n        ];\n        function i() {\n            t.containerNode().style.height = `${function() {\n                const { slideRegistry: e } = t.internalEngine();\n                return e[t.selectedScrollSnap()].map((e)=>n[e]).reduce((e, t)=>Math.max(e, t), 0);\n            }()}px`;\n        }\n        return {\n            name: \"autoHeight\",\n            options: e,\n            init: function(e) {\n                t = e;\n                const { options: { axis: s }, slideRects: l } = t.internalEngine();\n                \"y\" !== s && (n = l.map((e)=>e.height), o.forEach((e)=>t.on(e, i)), i());\n            },\n            destroy: function() {\n                o.forEach((e)=>t.off(e, i));\n                const e = t.containerNode();\n                e.style.height = \"\", e.getAttribute(\"style\") || e.removeAttribute(\"style\");\n            }\n        };\n    }\n    return e.globalOptions = void 0, e;\n});\n\n})();\n//# sourceMappingURL=embla-carousel.umd.js.map\n","// embla-carousel@8.2\n!function(n,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(n=\"undefined\"!=typeof globalThis?globalThis:n||self).EmblaCarousel=t()}(this,(function(){\"use strict\";function n(n){return\"number\"==typeof n}function t(n){return\"string\"==typeof n}function e(n){return\"boolean\"==typeof n}function r(n){return\"[object Object]\"===Object.prototype.toString.call(n)}function o(n){return Math.abs(n)}function i(n){return Math.sign(n)}function c(n,t){return o(n-t)}function u(n){return f(n).map(Number)}function s(n){return n[a(n)]}function a(n){return Math.max(0,n.length-1)}function d(n,t){return t===a(n)}function l(n,t=0){return Array.from(Array(n),((n,e)=>t+e))}function f(n){return Object.keys(n)}function p(n,t){return[n,t].reduce(((n,t)=>(f(t).forEach((e=>{const o=n[e],i=t[e],c=r(o)&&r(i);n[e]=c?p(o,i):i})),n)),{})}function m(n,t){return void 0!==t.MouseEvent&&n instanceof t.MouseEvent}function g(){let n=[];const t={add:function(e,r,o,i={passive:!0}){let c;if(\"addEventListener\"in e)e.addEventListener(r,o,i),c=()=>e.removeEventListener(r,o,i);else{const n=e;n.addListener(o),c=()=>n.removeListener(o)}return n.push(c),t},clear:function(){n=n.filter((n=>n()))}};return t}function h(n,t,e,r){const o=g(),i=1e3/60;let c=null,u=0,s=0;function a(n){if(!s)return;c||(c=n);const o=n-c;for(c=n,u+=o;u>=i;)e(i),u-=i;r(u/i),s&&t.requestAnimationFrame(a)}function d(){t.cancelAnimationFrame(s),c=null,u=0,s=0}return{init:function(){o.add(n,\"visibilitychange\",(()=>{n.hidden&&(c=null,u=0)}))},destroy:function(){d(),o.clear()},start:function(){s||(s=t.requestAnimationFrame(a))},stop:d,update:()=>e(i),render:r}}function x(n=0,t=0){const e=o(n-t);function r(t){return t<n}function i(n){return n>t}function c(n){return r(n)||i(n)}return{length:e,max:t,min:n,constrain:function(e){return c(e)?r(e)?n:t:e},reachedAny:c,reachedMax:i,reachedMin:r,removeOffset:function(n){return e?n-e*Math.ceil((n-t)/e):n}}}function y(n,t,e){const{constrain:r}=x(0,n),i=n+1;let c=u(t);function u(n){return e?o((i+n)%i):r(n)}function s(){return c}function a(){return y(n,s(),e)}const d={get:s,set:function(n){return c=u(n),d},add:function(n){return a().set(s()+n)},clone:a};return d}function v(n,t,r,u,s,a,d,l,f,p,h,y,v,b,S,w,E,L,D){const{cross:I,direction:A}=n,F=[\"INPUT\",\"SELECT\",\"TEXTAREA\"],M={passive:!1},T=g(),O=g(),P=x(50,225).constrain(b.measure(20)),z={mouse:300,touch:400},H={mouse:500,touch:600},k=S?43:25;let V=!1,B=0,C=0,N=!1,R=!1,j=!1,G=!1;function q(n){if(!m(n,u)&&n.touches.length>=2)return U(n);const t=a.readPoint(n),e=a.readPoint(n,I),r=c(t,B),o=c(e,C);if(!R&&!G){if(!n.cancelable)return U(n);if(R=r>o,!R)return U(n)}const i=a.pointerMove(n);r>w&&(j=!0),p.useFriction(.3).useDuration(.75),l.start(),s.add(A(i)),n.preventDefault()}function U(n){const t=h.byDistance(0,!1).index!==y.get(),e=a.pointerUp(n)*(S?H:z)[G?\"mouse\":\"touch\"],r=function(n,t){const e=y.add(-1*i(n)),r=h.byDistance(n,!S).distance;return S||o(n)<P?r:E&&t?.5*r:h.byIndex(e.get(),0).distance}(A(e),t),u=function(n,t){if(0===n||0===t)return 0;if(o(n)<=o(t))return 0;const e=c(o(n),o(t));return o(e/n)}(e,r),s=k-10*u,d=L+u/50;R=!1,N=!1,O.clear(),p.useDuration(s).useFriction(d),f.distance(r,!S),G=!1,v.emit(\"pointerUp\")}function W(n){j&&(n.stopPropagation(),n.preventDefault(),j=!1)}return{init:function(n){if(!D)return;function o(o){(e(D)||D(n,o))&&function(n){const e=m(n,u);if(G=e,j=S&&e&&!n.buttons&&V,V=c(s.get(),d.get())>=2,e&&0!==n.button)return;if(function(n){const t=n.nodeName||\"\";return F.includes(t)}(n.target))return;N=!0,a.pointerDown(n),p.useFriction(0).useDuration(0),s.set(d),function(){const n=G?r:t;O.add(n,\"touchmove\",q,M).add(n,\"touchend\",U).add(n,\"mousemove\",q,M).add(n,\"mouseup\",U)}(),B=a.readPoint(n),C=a.readPoint(n,I),v.emit(\"pointerDown\")}(o)}const i=t;T.add(i,\"dragstart\",(n=>n.preventDefault()),M).add(i,\"touchmove\",(()=>{}),M).add(i,\"touchend\",(()=>{})).add(i,\"touchstart\",o).add(i,\"mousedown\",o).add(i,\"touchcancel\",U).add(i,\"contextmenu\",U).add(i,\"click\",W,!0)},destroy:function(){T.clear(),O.clear()},pointerDown:function(){return N}}}function b(n,t){let e,r;function i(n){return n.timeStamp}function c(e,r){const o=\"client\"+(\"x\"===(r||n.scroll)?\"X\":\"Y\");return(m(e,t)?e:e.touches[0])[o]}return{pointerDown:function(n){return e=n,r=n,c(n)},pointerMove:function(n){const t=c(n)-c(r),o=i(n)-i(e)>170;return r=n,o&&(e=n),t},pointerUp:function(n){if(!e||!r)return 0;const t=c(r)-c(e),u=i(n)-i(e),s=i(n)-i(r)>170,a=t/u;return u&&!s&&o(a)>.1?a:0},readPoint:c}}function S(n,t,r,i,c,u,s){const a=[n].concat(i);let d,l,f=[],p=!1;function m(n){return c.measureSize(s.measure(n))}return{init:function(c){u&&(l=m(n),f=i.map(m),d=new ResizeObserver((r=>{(e(u)||u(c,r))&&function(e){for(const r of e){if(p)return;const e=r.target===n,u=i.indexOf(r.target),s=e?l:f[u];if(o(m(e?n:i[u])-s)>=.5){c.reInit(),t.emit(\"resize\");break}}}(r)})),r.requestAnimationFrame((()=>{a.forEach((n=>d.observe(n)))})))},destroy:function(){p=!0,d&&d.disconnect()}}}function w(n,t,e,r,i){const c=i.measure(10),u=i.measure(50),s=x(.1,.99);let a=!1;function d(){return!a&&(!!n.reachedAny(e.get())&&!!n.reachedAny(t.get()))}return{shouldConstrain:d,constrain:function(i){if(!d())return;const a=n.reachedMin(t.get())?\"min\":\"max\",l=o(n[a]-t.get()),f=e.get()-t.get(),p=s.constrain(l/u);e.subtract(f*p),!i&&o(f)<c&&(e.set(n.constrain(e.get())),r.useDuration(25).useBaseFriction())},toggleActive:function(n){a=!n}}}function E(n,t,e,r){const o=t.min+.1,i=t.max+.1,{reachedMin:c,reachedMax:u}=x(o,i);return{loop:function(t){if(!function(n){return 1===n?u(e.get()):-1===n&&c(e.get())}(t))return;const o=n*(-1*t);r.forEach((n=>n.add(o)))}}}function L(n,t,e,r,c){const{reachedAny:u,removeOffset:a,constrain:d}=r;function l(n){return n.concat().sort(((n,t)=>o(n)-o(t)))[0]}function f(t,r){const o=[t,t+e,t-e];if(!n)return t;if(!r)return l(o);const c=o.filter((n=>i(n)===r));return c.length?l(c):s(o)-e}return{byDistance:function(e,r){const i=c.get()+e,{index:s,distance:l}=function(e){const r=n?a(e):d(e),i=t.map(((n,t)=>({diff:f(n-r,0),index:t}))).sort(((n,t)=>o(n.diff)-o(t.diff))),{index:c}=i[0];return{index:c,distance:r}}(i),p=!n&&u(i);return!r||p?{index:s,distance:e}:{index:s,distance:e+f(t[s]-l,0)}},byIndex:function(n,e){return{index:n,distance:f(t[n]-c.get(),e)}},shortcut:f}}function D(t,r,o,i,c,u,s,a){const d={passive:!0,capture:!0};let l=0;function f(n){\"Tab\"===n.code&&(l=(new Date).getTime())}return{init:function(p){a&&(u.add(document,\"keydown\",f,!1),r.forEach(((r,f)=>{u.add(r,\"focus\",(r=>{(e(a)||a(p,r))&&function(e){if((new Date).getTime()-l>10)return;s.emit(\"slideFocusStart\"),t.scrollLeft=0;const r=o.findIndex((n=>n.includes(e)));n(r)&&(c.useDuration(0),i.index(r,0),s.emit(\"slideFocus\"))}(f)}),d)})))}}}function I(t){let e=t;function r(t){return n(t)?t:t.get()}return{get:function(){return e},set:function(n){e=r(n)},add:function(n){e+=r(n)},subtract:function(n){e-=r(n)}}}function A(n,t){const e=\"x\"===n.scroll?function(n){return`translate3d(${n}px,0px,0px)`}:function(n){return`translate3d(0px,${n}px,0px)`},r=t.style;let o=!1;return{clear:function(){o||(r.transform=\"\",t.getAttribute(\"style\")||t.removeAttribute(\"style\"))},to:function(t){o||(r.transform=e(n.direction(t)))},toggleActive:function(n){o=!n}}}function F(n,t,e,r,o,i,c,s,a){const d=.5,l=u(o),f=u(o).reverse(),p=function(){const n=c[0];return h(g(f,n),e,!1)}().concat(function(){const n=t-c[0]-1;return h(g(l,n),-e,!0)}());function m(n,t){return n.reduce(((n,t)=>n-o[t]),t)}function g(n,t){return n.reduce(((n,e)=>m(n,t)>0?n.concat([e]):n),[])}function h(o,c,u){const l=function(n){return i.map(((e,o)=>({start:e-r[o]+d+n,end:e+t-d+n})))}(c);return o.map((t=>{const r=u?0:-e,o=u?e:0,i=u?\"end\":\"start\",c=l[t][i];return{index:t,loopPoint:c,slideLocation:I(-1),translate:A(n,a[t]),target:()=>s.get()>c?r:o}}))}return{canLoop:function(){return p.every((({index:n})=>m(l.filter((t=>t!==n)),t)<=.1))},clear:function(){p.forEach((n=>n.translate.clear()))},loop:function(){p.forEach((n=>{const{target:t,translate:e,slideLocation:r}=n,o=t();o!==r.get()&&(e.to(o),r.set(o))}))},loopPoints:p}}function M(n,t,r){let o,i=!1;return{init:function(c){r&&(o=new MutationObserver((n=>{i||(e(r)||r(c,n))&&function(n){for(const e of n)if(\"childList\"===e.type){c.reInit(),t.emit(\"slidesChanged\");break}}(n)})),o.observe(n,{childList:!0}))},destroy:function(){o&&o.disconnect(),i=!0}}}function T(n,t,e,r){const o={};let i,c=null,u=null,s=!1;return{init:function(){i=new IntersectionObserver((n=>{s||(n.forEach((n=>{const e=t.indexOf(n.target);o[e]=n})),c=null,u=null,e.emit(\"slidesInView\"))}),{root:n.parentElement,threshold:r}),t.forEach((n=>i.observe(n)))},destroy:function(){i&&i.disconnect(),s=!0},get:function(n=!0){if(n&&c)return c;if(!n&&u)return u;const t=function(n){return f(o).reduce(((t,e)=>{const r=parseInt(e),{isIntersecting:i}=o[r];return(n&&i||!n&&!i)&&t.push(r),t}),[])}(n);return n&&(c=t),n||(u=t),t}}}function O(t,e,r,i,c,d,l,f,p){const{startEdge:m,endEdge:g,direction:h}=t,x=n(r);return{groupSlides:function(n){return x?function(n,t){return u(n).filter((n=>n%t==0)).map((e=>n.slice(e,e+t)))}(n,r):function(n){return n.length?u(n).reduce(((t,r,u)=>{const x=s(t)||0,y=0===x,v=r===a(n),b=c[m]-d[x][m],S=c[m]-d[r][g],w=!i&&y?h(l):0,E=o(S-(!i&&v?h(f):0)-(b+w));return u&&E>e+p&&t.push(r),v&&t.push(n.length),t}),[]).map(((t,e,r)=>{const o=Math.max(r[e-1]||0);return n.slice(o,t)})):[]}(n)}}}function P(n,e,r,f,p,m,P){const{align:z,axis:H,direction:k,startIndex:V,loop:B,duration:C,dragFree:N,dragThreshold:R,inViewThreshold:j,slidesToScroll:G,skipSnaps:q,containScroll:U,watchResize:W,watchSlides:$,watchDrag:Q,watchFocus:X}=m,Y={measure:function(n){const{offsetTop:t,offsetLeft:e,offsetWidth:r,offsetHeight:o}=n;return{top:t,right:e+r,bottom:t+o,left:e,width:r,height:o}}},J=Y.measure(e),K=r.map(Y.measure),Z=function(n,t){const e=\"rtl\"===t,r=\"y\"===n,o=!r&&e?-1:1;return{scroll:r?\"y\":\"x\",cross:r?\"x\":\"y\",startEdge:r?\"top\":e?\"right\":\"left\",endEdge:r?\"bottom\":e?\"left\":\"right\",measureSize:function(n){const{height:t,width:e}=n;return r?t:e},direction:function(n){return n*o}}}(H,k),_=Z.measureSize(J),nn=function(n){return{measure:function(t){return n*(t/100)}}}(_),tn=function(n,e){const r={start:function(){return 0},center:function(n){return o(n)/2},end:o};function o(n){return e-n}return{measure:function(o,i){return t(n)?r[n](o):n(e,o,i)}}}(z,_),en=!B&&!!U,rn=B||!!U,{slideSizes:on,slideSizesWithGaps:cn,startGap:un,endGap:sn}=function(n,t,e,r,i,c){const{measureSize:u,startEdge:a,endEdge:l}=n,f=e[0]&&i,p=function(){if(!f)return 0;const n=e[0];return o(t[a]-n[a])}(),m=function(){if(!f)return 0;const n=c.getComputedStyle(s(r));return parseFloat(n.getPropertyValue(`margin-${l}`))}(),g=e.map(u),h=e.map(((n,t,e)=>{const r=!t,o=d(e,t);return r?g[t]+p:o?g[t]+m:e[t+1][a]-n[a]})).map(o);return{slideSizes:g,slideSizesWithGaps:h,startGap:p,endGap:m}}(Z,J,K,r,rn,p),an=O(Z,_,G,B,J,K,un,sn,2),{snaps:dn,snapsAligned:ln}=function(n,t,e,r,i){const{startEdge:c,endEdge:u}=n,{groupSlides:a}=i,d=a(r).map((n=>s(n)[u]-n[0][c])).map(o).map(t.measure),l=r.map((n=>e[c]-n[c])).map((n=>-o(n))),f=a(l).map((n=>n[0])).map(((n,t)=>n+d[t]));return{snaps:l,snapsAligned:f}}(Z,tn,J,K,an),fn=-s(dn)+s(cn),{snapsContained:pn,scrollContainLimit:mn}=function(n,t,e,r,o){const i=x(-t+n,0),u=e.map(((n,t)=>{const{min:r,max:o}=i,c=i.constrain(n),u=!t,s=d(e,t);return u?o:s||l(r,c)?r:l(o,c)?o:c})).map((n=>parseFloat(n.toFixed(3)))),a=function(){const n=u[0],t=s(u);return x(u.lastIndexOf(n),u.indexOf(t)+1)}();function l(n,t){return c(n,t)<1}return{snapsContained:function(){if(t<=n+o)return[i.max];if(\"keepSnaps\"===r)return u;const{min:e,max:c}=a;return u.slice(e,c)}(),scrollContainLimit:a}}(_,fn,ln,U,2),gn=en?pn:ln,{limit:hn}=function(n,t,e){const r=t[0];return{limit:x(e?r-n:s(t),r)}}(fn,gn,B),xn=y(a(gn),V,B),yn=xn.clone(),vn=u(r),bn=h(f,p,(n=>(({dragHandler:n,scrollBody:t,scrollBounds:e,options:{loop:r}},o)=>{r||e.constrain(n.pointerDown()),t.seek(o)})(Hn,n)),(n=>(({scrollBody:n,translate:t,location:e,offsetLocation:r,scrollLooper:o,slideLooper:i,dragHandler:c,animation:u,eventHandler:s,scrollBounds:a,options:{loop:d}},l)=>{const f=n.settled(),p=!a.shouldConstrain(),m=d?f:f&&p;m&&!c.pointerDown()&&(u.stop(),s.emit(\"settle\")),m||s.emit(\"scroll\");const g=e.get()*l+En.get()*(1-l);r.set(g),d&&(o.loop(n.direction()),i.loop()),t.to(r.get())})(Hn,n))),Sn=gn[xn.get()],wn=I(Sn),En=I(Sn),Ln=I(Sn),Dn=I(Sn),In=function(n,t,e,r,c,u){let s=0,a=0,d=c,l=u,f=n.get(),p=0;function m(n){return d=n,h}function g(n){return l=n,h}const h={direction:function(){return a},duration:function(){return d},velocity:function(){return s},seek:function(t){const o=t/1e3,c=d*o,u=r.get()-n.get();let m=0;return d?(e.set(n),s+=u/c,s*=l,f+=s,n.add(s*o),m=f-p):(s=0,e.set(r),n.set(r),m=u),a=i(m),p=f,h},settled:function(){return o(r.get()-t.get())<.001},useBaseFriction:function(){return g(u)},useBaseDuration:function(){return m(c)},useFriction:g,useDuration:m};return h}(wn,Ln,En,Dn,C,.68),An=L(B,gn,fn,hn,Dn),Fn=function(n,t,e,r,o,i,c){function u(o){const u=o.distance,s=o.index!==t.get();i.add(u),u&&(r.duration()?n.start():(n.update(),n.render(1),n.update())),s&&(e.set(t.get()),t.set(o.index),c.emit(\"select\"))}return{distance:function(n,t){u(o.byDistance(n,t))},index:function(n,e){const r=t.clone().set(n);u(o.byIndex(r.get(),e))}}}(bn,xn,yn,In,An,Dn,P),Mn=function(n){const{max:t,length:e}=n;return{get:function(n){return e?(n-t)/-e:0}}}(hn),Tn=g(),On=T(e,r,P,j),{slideRegistry:Pn}=function(n,t,e,r,o,i){const{groupSlides:c}=o,{min:u,max:f}=r;return{slideRegistry:function(){const r=c(i),o=!n||\"keepSnaps\"===t;return 1===e.length?[i]:o?r:r.slice(u,f).map(((n,t,e)=>{const r=!t,o=d(e,t);return r?l(s(e[0])+1):o?l(a(i)-s(e)[0]+1,s(e)[0]):n}))}()}}(en,U,gn,mn,an,vn),zn=D(n,r,Pn,Fn,In,Tn,P,X),Hn={ownerDocument:f,ownerWindow:p,eventHandler:P,containerRect:J,slideRects:K,animation:bn,axis:Z,dragHandler:v(Z,n,f,p,Dn,b(Z,p),wn,bn,Fn,In,An,xn,P,nn,N,R,q,.68,Q),eventStore:Tn,percentOfView:nn,index:xn,indexPrevious:yn,limit:hn,location:wn,offsetLocation:Ln,previousLocation:En,options:m,resizeHandler:S(e,P,p,r,Z,W,Y),scrollBody:In,scrollBounds:w(hn,Ln,Dn,In,nn),scrollLooper:E(fn,hn,Ln,[wn,Ln,En,Dn]),scrollProgress:Mn,scrollSnapList:gn.map(Mn.get),scrollSnaps:gn,scrollTarget:An,scrollTo:Fn,slideLooper:F(Z,_,fn,on,cn,dn,gn,Ln,r),slideFocus:zn,slidesHandler:M(e,P,$),slidesInView:On,slideIndexes:vn,slideRegistry:Pn,slidesToScroll:an,target:Dn,translate:A(Z,e)};return Hn}const z={align:\"center\",axis:\"x\",container:null,slides:null,containScroll:\"trimSnaps\",direction:\"ltr\",slidesToScroll:1,inViewThreshold:0,breakpoints:{},dragFree:!1,dragThreshold:10,loop:!1,skipSnaps:!1,duration:25,startIndex:0,active:!0,watchDrag:!0,watchResize:!0,watchSlides:!0,watchFocus:!0};function H(n){function t(n,t){return p(n,t||{})}const e={mergeOptions:t,optionsAtMedia:function(e){const r=e.breakpoints||{},o=f(r).filter((t=>n.matchMedia(t).matches)).map((n=>r[n])).reduce(((n,e)=>t(n,e)),{});return t(e,o)},optionsMediaQueries:function(t){return t.map((n=>f(n.breakpoints||{}))).reduce(((n,t)=>n.concat(t)),[]).map(n.matchMedia)}};return e}function k(n,e,r){const o=n.ownerDocument,i=o.defaultView,c=H(i),u=function(n){let t=[];return{init:function(e,r){return t=r.filter((({options:t})=>!1!==n.optionsAtMedia(t).active)),t.forEach((t=>t.init(e,n))),r.reduce(((n,t)=>Object.assign(n,{[t.name]:t})),{})},destroy:function(){t=t.filter((n=>n.destroy()))}}}(c),s=g(),a=function(){let n,t={};function e(n){return t[n]||[]}const r={init:function(t){n=t},emit:function(t){return e(t).forEach((e=>e(n,t))),r},off:function(n,o){return t[n]=e(n).filter((n=>n!==o)),r},on:function(n,o){return t[n]=e(n).concat([o]),r},clear:function(){t={}}};return r}(),{mergeOptions:d,optionsAtMedia:l,optionsMediaQueries:f}=c,{on:p,off:m,emit:h}=a,x=F;let y,v,b,S,w=!1,E=d(z,k.globalOptions),L=d(E),D=[];function I(t){const e=P(n,b,S,o,i,t,a);if(t.loop&&!e.slideLooper.canLoop()){return I(Object.assign({},t,{loop:!1}))}return e}function A(e,r){w||(E=d(E,e),L=l(E),D=r||D,function(){const{container:e,slides:r}=L,o=t(e)?n.querySelector(e):e;b=o||n.children[0];const i=t(r)?b.querySelectorAll(r):r;S=[].slice.call(i||b.children)}(),y=I(L),f([E,...D.map((({options:n})=>n))]).forEach((n=>s.add(n,\"change\",F))),L.active&&(y.translate.to(y.location.get()),y.animation.init(),y.slidesInView.init(),y.slideFocus.init(V),y.eventHandler.init(V),y.resizeHandler.init(V),y.slidesHandler.init(V),y.options.loop&&y.slideLooper.loop(),b.offsetParent&&S.length&&y.dragHandler.init(V),v=u.init(V,D)))}function F(n,t){const e=O();M(),A(d({startIndex:e},n),t),a.emit(\"reInit\")}function M(){y.dragHandler.destroy(),y.eventStore.clear(),y.translate.clear(),y.slideLooper.clear(),y.resizeHandler.destroy(),y.slidesHandler.destroy(),y.slidesInView.destroy(),y.animation.destroy(),u.destroy(),s.clear()}function T(n,t,e){L.active&&!w&&(y.scrollBody.useBaseFriction().useDuration(!0===t?0:L.duration),y.scrollTo.index(n,e||0))}function O(){return y.index.get()}const V={canScrollNext:function(){return y.index.add(1).get()!==O()},canScrollPrev:function(){return y.index.add(-1).get()!==O()},containerNode:function(){return b},internalEngine:function(){return y},destroy:function(){w||(w=!0,s.clear(),M(),a.emit(\"destroy\"),a.clear())},off:m,on:p,emit:h,plugins:function(){return v},previousScrollSnap:function(){return y.indexPrevious.get()},reInit:x,rootNode:function(){return n},scrollNext:function(n){T(y.index.add(1).get(),n,-1)},scrollPrev:function(n){T(y.index.add(-1).get(),n,1)},scrollProgress:function(){return y.scrollProgress.get(y.location.get())},scrollSnapList:function(){return y.scrollSnapList},scrollTo:T,selectedScrollSnap:O,slideNodes:function(){return S},slidesInView:function(){return y.slidesInView.get()},slidesNotInView:function(){return y.slidesInView.get(!1)}};return A(e,r),setTimeout((()=>a.emit(\"init\")),0),V}return k.globalOptions=void 0,k}));\n// wheel-gestures\n!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(e=e||self).EmblaCarouselWheelGestures=t()}(this,(function(){\"use strict\";function e(){return(e=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i])}return e}).apply(this,arguments)}function t(e,t){if(e.length!==t.length)throw new Error(\"vectors must be same length\");return e.map((function(e,n){return e+t[n]}))}function n(e){return Math.max.apply(Math,e.map(Math.abs))}function i(e){return Object.freeze(e),Object.values(e).forEach((function(e){null===e||\"object\"!=typeof e||Object.isFrozen(e)||i(e)})),e}var o=[1,18,\"undefined\"!=typeof window&&window.innerHeight||800],r=[-1,-1,-1],a=i({preventWheelAction:!0,reverseSign:[!0,!0,!1]}),s={active:!0,breakpoints:{},wheelDraggingClass:\"is-wheel-dragging\",forceWheelAxis:void 0,target:void 0};function u(c){var l;void 0===c&&(c={});var m=function(){};return{name:\"wheelGestures\",options:c,init:function(f,d){var v,h,p=d.mergeOptions,M=d.optionsAtMedia,g=p(s,u.globalOptions),x=p(g,c);l=M(x);var b,E=f.internalEngine(),w=null!=(v=l.target)?v:f.containerNode().parentNode,y=null!=(h=l.forceWheelAxis)?h:E.options.axis,S=function(s){void 0===s&&(s={});var u,c,l,m=function(){var e={};function t(t,n){e[t]=(e[t]||[]).filter((function(e){return e!==n}))}return i({on:function(n,i){return e[n]=(e[n]||[]).concat(i),function(){return t(n,i)}},off:t,dispatch:function(t,n){t in e&&e[t].forEach((function(e){return e(n)}))}})}(),f=m.on,d=m.off,v=m.dispatch,h=a,p={isStarted:!1,isStartPublished:!1,isMomentum:!1,startTime:0,lastAbsDelta:Infinity,axisMovement:[0,0,0],axisVelocity:[0,0,0],accelerationFactors:[],scrollPoints:[],scrollPointsToMerge:[],willEndTimeout:400},M=!1,g=function(e){Array.isArray(e)?e.forEach((function(e){return E(e)})):E(e)},x=function(t){return void 0===t&&(t={}),Object.values(t).some((function(e){return null==e}))?h:h=i(e({},a,h,t))},b=function(n){var i=e({event:u,isStart:!1,isEnding:!1,isMomentumCancel:!1,isMomentum:p.isMomentum,axisDelta:[0,0,0],axisVelocity:p.axisVelocity,axisMovement:p.axisMovement,get axisMovementProjection(){return t(i.axisMovement,i.axisVelocity.map((function(e){return void 0===t&&(t=.996),e*t/(1-t);var t})))}},n);v(\"wheel\",e({},i,{previous:c})),c=i},E=function(i){var a,s=function(t){return e({},t,{axisDelta:t.axisDelta.map((function(e){return Math.min(Math.max(-700,e),700)}))})}(function(t,n){if(!n)return t;var i=!0===n?r:n.map((function(e){return e?-1:1}));return e({},t,{axisDelta:t.axisDelta.map((function(e,t){return e*i[t]}))})}({timeStamp:(a=i).timeStamp,axisDelta:[a.deltaX*o[a.deltaMode],a.deltaY*o[a.deltaMode],(a.deltaZ||0)*o[a.deltaMode]]},h.reverseSign)),c=s.axisDelta,l=s.timeStamp,m=n(c);i.preventDefault&&function(e,t){var n=h.preventWheelAction,i=t[0],o=t[1],r=t[2];if(\"boolean\"==typeof n)return n;switch(n){case\"x\":return Math.abs(i)>=e;case\"y\":return Math.abs(o)>=e;case\"z\":return Math.abs(r)>=e;default:return!1}}(m,c)&&i.preventDefault(),p.isStarted?p.isMomentum&&m>Math.max(2,2*p.lastAbsDelta)&&(L(!0),A()):A(),0===m&&Object.is&&Object.is(i.deltaX,-0)?M=!0:(u=i,p.axisMovement=t(p.axisMovement,c),p.lastAbsDelta=m,p.scrollPointsToMerge.push({axisDelta:c,timeStamp:l}),w(),b({axisDelta:c,isStart:!p.isStartPublished}),p.isStartPublished=!0,j())},w=function(){var e;2===p.scrollPointsToMerge.length?(p.scrollPoints.unshift({axisDeltaSum:p.scrollPointsToMerge.map((function(e){return e.axisDelta})).reduce(t),timeStamp:(e=p.scrollPointsToMerge.map((function(e){return e.timeStamp})),e.reduce((function(e,t){return e+t}))/e.length)}),S(),p.scrollPointsToMerge.length=0,p.scrollPoints.length=1,p.isMomentum||T()):p.isStartPublished||y()},y=function(){var e;p.axisVelocity=(e=p.scrollPointsToMerge,e[e.length-1]).axisDelta.map((function(e){return e/p.willEndTimeout}))},S=function(){var e=p.scrollPoints,t=e[0],n=e[1];if(n&&t){var i=t.timeStamp-n.timeStamp;if(!(i<=0)){var o=t.axisDeltaSum.map((function(e){return e/i})),r=o.map((function(e,t){return e/(p.axisVelocity[t]||1)}));p.axisVelocity=o,p.accelerationFactors.push(r),D(i)}}},D=function(e){var t=10*Math.ceil(e/10)*1.2;p.isMomentum||(t=Math.max(100,2*t)),p.willEndTimeout=Math.min(1e3,Math.round(t))},P=function(e){return 0===e||e<=.96&&e>=.6},T=function(){if(p.accelerationFactors.length>=5){if(M&&(M=!1,n(p.axisVelocity)>=.2))return void O();var e=p.accelerationFactors.slice(-5);e.every((function(e){var t=!!e.reduce((function(e,t){return e&&e<1&&e===t?1:0})),n=e.filter(P).length===e.length;return t||n}))&&O(),p.accelerationFactors=e}},O=function(){p.isMomentum=!0},A=function(){(p={isStarted:!1,isStartPublished:!1,isMomentum:!1,startTime:0,lastAbsDelta:Infinity,axisMovement:[0,0,0],axisVelocity:[0,0,0],accelerationFactors:[],scrollPoints:[],scrollPointsToMerge:[],willEndTimeout:400}).isStarted=!0,p.startTime=Date.now(),c=void 0,M=!1},j=function(){clearTimeout(l),l=setTimeout(L,p.willEndTimeout)},L=function(e){void 0===e&&(e=!1),p.isStarted&&(b(p.isMomentum&&e?{isEnding:!0,isMomentumCancel:!0}:{isEnding:!0}),p.isMomentum=!1,p.isStarted=!1)},V=function(e){var t=[],n=function(n){n.removeEventListener(\"wheel\",e),t=t.filter((function(e){return e!==n}))};return i({observe:function(i){return i.addEventListener(\"wheel\",e,{passive:!1}),t.push(i),function(){return n(i)}},unobserve:n,disconnect:function(){t.forEach(n)}})}(g),C=V.observe,F=V.unobserve,W=V.disconnect;return x(s),i({on:f,off:d,observe:C,unobserve:F,disconnect:W,feedWheel:g,updateOptions:x})}({preventWheelAction:y,reverseSign:[!0,!0,!1]}),D=S.observe(w),P=S.on(\"wheel\",(function(e){var t=e.axisDelta,n=t[0],i=t[1],o=\"x\"===y?i:n,r=e.isEnding&&!e.isMomentum||e.isMomentum&&e.previous&&!e.previous.isMomentum;Math.abs(\"x\"===y?n:i)>Math.abs(o)&&!T&&!e.isMomentum&&function(e){try{L(b=new MouseEvent(\"mousedown\",e.event))}catch(e){return m()}T=!0,document.documentElement.addEventListener(\"mousemove\",A,!0),document.documentElement.addEventListener(\"mouseup\",A,!0),document.documentElement.addEventListener(\"mousedown\",A,!0),l.wheelDraggingClass&&w.classList.add(l.wheelDraggingClass)}(e),T&&(r?function(e){T=!1,L(j(\"mouseup\",e)),O(),l.wheelDraggingClass&&w.classList.remove(l.wheelDraggingClass)}(e):L(j(\"mousemove\",e)))})),T=!1;function O(){document.documentElement.removeEventListener(\"mousemove\",A,!0),document.documentElement.removeEventListener(\"mouseup\",A,!0),document.documentElement.removeEventListener(\"mousedown\",A,!0)}function A(e){T&&e.isTrusted&&e.stopImmediatePropagation()}function j(e,t){var n,i;if(y===E.options.axis){var o=t.axisMovement;n=o[0],i=o[1]}else{var r=t.axisMovement;i=r[0],n=r[1]}if(!E.options.skipSnaps&&!E.options.dragFree){var a=E.containerRect.width,s=E.containerRect.height;n=n<0?Math.max(n,-a):Math.min(n,a),i=i<0?Math.max(i,-s):Math.min(i,s)}return new MouseEvent(e,{clientX:b.clientX+n,clientY:b.clientY+i,screenX:b.screenX+n,screenY:b.screenY+i,movementX:n,movementY:i,button:0,bubbles:!0,cancelable:!0,composed:!0})}function L(e){f.containerNode().dispatchEvent(e)}m=function(){D(),P(),O()}},destroy:function(){return m()}}}return u.globalOptions=void 0,u}));\n//# sourceMappingURL=embla-carousel-wheel-gestures.umd.js.map\n// fade\n!function(n,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(n=\"undefined\"!=typeof globalThis?globalThis:n||self).EmblaCarouselFade=t()}(this,(function(){\"use strict\";function n(n,t,e){return Math.min(Math.max(n,t),e)}function t(n){return\"number\"==typeof n&&!isNaN(n)}function e(e={}){const o=1,i=0,r=.68,s=1e3/60;let l,c,a,f,d=[],u=0,p=0,g=0,y=!1;function E(){v(l.selectedScrollSnap(),o)}function S(){y=!1}function h(){y=!1,u=0,p=0}function m(){const n=l.internalEngine().scrollBody.duration();p=n?0:o,y=!0,n||E()}function b(n){const{scrollSnaps:e,location:o,target:i}=l.internalEngine();!t(n)||d[n]<.5||(o.set(e[n]),i.set(o))}function v(t,e){l.scrollSnapList().forEach(((r,s)=>{const c=Math.abs(e),a=d[s],f=s===t,p=n(f?a+c:a-c,i,o);d[s]=p;const E=f&&y,S=l.previousScrollSnap();E&&(d[S]=1-p),f&&function(n,t){const{index:e,dragHandler:o,scrollSnaps:i}=l.internalEngine(),r=o.pointerDown(),s=1/(i.length-1);let c=n,a=r?l.selectedScrollSnap():l.previousScrollSnap();if(r&&c===a){const n=-1*Math.sign(u);c=a,a=e.clone().set(a).add(n).get()}const f=a*s,d=(c-a)*s;g=f+d*t}(t,p),function(n){const t=l.internalEngine().slideRegistry[n],{scrollSnaps:e,containerRect:o}=l.internalEngine(),r=d[n];t.forEach((t=>{const s=l.slideNodes()[t].style,c=parseFloat(r.toFixed(2)),a=c>i,f=function(n){const{axis:t}=l.internalEngine();return`translate${t.scroll.toUpperCase()}(${t.direction(n)}px)`}(a?e[n]:o.width+2);a&&(s.transform=f),s.opacity=c.toString(),s.pointerEvents=r>.5?\"auto\":\"none\",a||(s.transform=f)}))}(s)}))}function x(){const{dragHandler:n,index:t,scrollBody:e}=l.internalEngine(),o=l.selectedScrollSnap();if(!n.pointerDown())return o;const i=Math.sign(e.velocity()),r=Math.sign(u),s=t.clone().set(o).add(-1*i).get();return i&&r?r===i?s:o:null}function M(){const{target:n,location:e}=l.internalEngine(),i=n.get()-e.get(),a=Math.abs(i)>=1,f=x(),g=!t(f);return function(n){const{dragHandler:e,scrollBody:i}=n.internalEngine(),l=s/1e3,a=e.pointerDown(),f=i.velocity()*l,g=i.duration(),y=x(),E=!t(y);if(a){if(!f)return;u+=f,p=Math.abs(f/c),b(y)}if(!a){if(!g||E)return;p+=(o-d[y])/g,p*=r}E||v(y,p)}(l),!g&&!a&&d[f]>.999}function w(){return g}return{name:\"fade\",options:e,init:function(t){l=t;const e=l.selectedScrollSnap(),{scrollBody:r,containerRect:s,axis:u}=l.internalEngine(),p=u.measureSize(s);c=n(.75*p,200,500),y=!1,d=l.scrollSnapList().map(((n,t)=>t===e?o:i)),a=r.settled,f=l.scrollProgress,r.settled=M,l.scrollProgress=w,l.on(\"select\",m).on(\"slideFocus\",E).on(\"pointerDown\",h).on(\"pointerUp\",S),function(){const{translate:n,slideLooper:t}=l.internalEngine();n.clear(),n.toggleActive(!1),t.loopPoints.forEach((({translate:n})=>{n.clear(),n.toggleActive(!1)}))}(),E()},destroy:function(){const{scrollBody:n}=l.internalEngine();n.settled=a,l.scrollProgress=f,l.off(\"select\",m).off(\"slideFocus\",E).off(\"pointerDown\",h).off(\"pointerUp\",S),l.slideNodes().forEach((n=>{const t=n.style;t.opacity=\"\",t.transform=\"\",t.pointerEvents=\"\",n.getAttribute(\"style\")||n.removeAttribute(\"style\")}))}}}return e.globalOptions=void 0,e}));\n// class-names\n!function(n,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(n=\"undefined\"!=typeof globalThis?globalThis:n||self).EmblaCarouselClassNames=e()}(this,(function(){\"use strict\";const n={active:!0,breakpoints:{},snapped:\"is-snapped\",inView:\"is-in-view\",draggable:\"is-draggable\",dragging:\"is-dragging\"};function e(n,e){if(!n||!e)return;const{classList:o}=n;o.contains(e)&&o.remove(e)}function o(n,e){if(!n||!e)return;const{classList:o}=n;o.contains(e)||o.add(e)}function i(t={}){let s,a,r,c;const f=[\"select\"],d=[\"pointerDown\",\"pointerUp\"],l=[\"slidesInView\"];function g(n,i){\"pointerDown\"===i?o(r,s.dragging):e(r,s.dragging)}function p(n,i){const t=a.containerNode().querySelectorAll(`.${i}`);var s;(s=t,Array.from(s)).forEach((n=>e(n,i))),n.forEach((n=>o(c[n],i)))}function u(){const{slideRegistry:n}=a.internalEngine();p(n[a.selectedScrollSnap()],s.snapped)}function h(){p(a.slidesInView(),s.inView)}return{name:\"classNames\",options:t,init:function(e,p){a=e;const{mergeOptions:E,optionsAtMedia:b}=p,m=E(n,i.globalOptions),w=E(m,t);s=b(w),r=a.rootNode(),c=a.slideNodes(),!!a.internalEngine().options.watchDrag&&o(r,s.draggable),s.dragging&&d.forEach((n=>a.on(n,g))),s.snapped&&(f.forEach((n=>a.on(n,u))),u()),s.inView&&(l.forEach((n=>a.on(n,h))),h())},destroy:function(){e(r,s.draggable),d.forEach((n=>a.off(n,g))),f.forEach((n=>a.off(n,u))),l.forEach((n=>a.off(n,h))),c.forEach((n=>e(n,s.snapped)))}}}return i.globalOptions=void 0,i}));\n// autoplay\n!function(n,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(n=\"undefined\"!=typeof globalThis?globalThis:n||self).EmblaCarouselAutoplay=t()}(this,(function(){\"use strict\";const n={active:!0,breakpoints:{},delay:4e3,jump:!1,playOnInit:!0,stopOnFocusIn:!0,stopOnInteraction:!0,stopOnMouseEnter:!1,stopOnLastSnap:!1,rootNode:null};function t(o={}){let e,i,r,a=!1,s=!0,l=!1,u=0;function c(){if(r)return;if(!s)return;a||i.emit(\"autoplay:play\");const{ownerWindow:n}=i.internalEngine();n.clearInterval(u),u=n.setInterval(g,e.delay),a=!0}function p(){if(r)return;a&&i.emit(\"autoplay:stop\");const{ownerWindow:n}=i.internalEngine();n.clearInterval(u),u=0,a=!1}function d(){if(f())return s=a,p();s&&c()}function f(){const{ownerDocument:n}=i.internalEngine();return\"hidden\"===n.visibilityState}function y(n){void 0!==n&&(l=n),s=!0,c()}function g(){const{index:n}=i.internalEngine(),t=n.clone().add(1).get(),o=i.scrollSnapList().length-1;e.stopOnLastSnap&&t===o&&p(),i.canScrollNext()?i.scrollNext(l):i.scrollTo(0,l)}return{name:\"autoplay\",options:o,init:function(a,u){i=a;const{mergeOptions:y,optionsAtMedia:g}=u,O=y(n,t.globalOptions),m=y(O,o);if(e=g(m),i.scrollSnapList().length<=1)return;l=e.jump,r=!1;const{eventStore:I,ownerDocument:v}=i.internalEngine(),b=i.rootNode(),w=e.rootNode&&e.rootNode(b)||b,E=i.containerNode();i.on(\"pointerDown\",p),e.stopOnInteraction||i.on(\"pointerUp\",c),e.stopOnMouseEnter&&(I.add(w,\"mouseenter\",(()=>{s=!1,p()})),e.stopOnInteraction||I.add(w,\"mouseleave\",(()=>{s=!0,c()}))),e.stopOnFocusIn&&(I.add(E,\"focusin\",p),e.stopOnInteraction||I.add(E,\"focusout\",c)),I.add(v,\"visibilitychange\",d),e.playOnInit&&!f()&&c()},destroy:function(){i.off(\"pointerDown\",p).off(\"pointerUp\",c),p(),r=!0,a=!1},play:y,stop:function(){a&&p()},reset:function(){a&&y()},isPlaying:function(){return a}}}return t.globalOptions=void 0,t}));\n// auto scroll\n!function(t,o){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=o():\"function\"==typeof define&&define.amd?define(o):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).EmblaCarouselAutoScroll=o()}(this,(function(){\"use strict\";const t={direction:\"forward\",speed:2,startDelay:1e3,active:!0,breakpoints:{},playOnInit:!0,stopOnFocusIn:!0,stopOnInteraction:!0,stopOnMouseEnter:!1,rootNode:null};function o(n={}){let e,i,r,s,c,l=!1,a=!0,u=0;function d(){if(r||l)return;if(!a)return;i.emit(\"autoScroll:play\");const t=i.internalEngine(),{ownerWindow:o}=t;u=o.setTimeout((()=>{t.scrollBody=function(t){const{location:o,previousLocation:n,offsetLocation:r,target:s,scrollTarget:c,index:l,indexPrevious:a,limit:{reachedMin:u,reachedMax:d,constrain:p},options:{loop:g}}=t,y=\"forward\"===e.direction?-1:1,m=()=>h;let O=0,w=0,b=o.get(),v=0,I=!1;function S(t){const m=t/1e3;let S=0;n.set(o),O=y*e.speed*55,b+=O,o.add(O*m),s.set(o),S=b-v,w=Math.sign(S),v=b;const D=c.byDistance(0,!1).index;l.get()!==D&&(a.set(l.get()),l.set(D),i.emit(\"select\"));const E=\"forward\"===e.direction?u(r.get()):d(r.get());if(!g&&E){I=!0;const t=p(o.get());o.set(t),s.set(o),f()}return h}const h={direction:()=>w,duration:()=>-1,velocity:()=>O,settled:()=>I,seek:S,useBaseFriction:m,useBaseDuration:m,useFriction:m,useDuration:m};return h}(t),t.animation.start()}),s),l=!0}function f(){if(r||!l)return;i.emit(\"autoScroll:stop\");const t=i.internalEngine(),{ownerWindow:o}=t;t.scrollBody=c,o.clearTimeout(u),u=0,l=!1}function p(){a&&d(),i.off(\"settle\",p)}function g(){i.on(\"settle\",p)}return{name:\"autoScroll\",options:n,init:function(l,u){i=l;const{mergeOptions:p,optionsAtMedia:y}=u,m=p(t,o.globalOptions),O=p(m,n);if(e=y(O),i.scrollSnapList().length<=1)return;s=e.startDelay,r=!1,c=i.internalEngine().scrollBody;const{eventStore:w}=i.internalEngine(),b=i.rootNode(),v=e.rootNode&&e.rootNode(b)||b,I=i.containerNode();i.on(\"pointerDown\",f),e.stopOnInteraction||i.on(\"pointerUp\",g),e.stopOnMouseEnter&&(w.add(v,\"mouseenter\",(()=>{a=!1,f()})),e.stopOnInteraction||w.add(v,\"mouseleave\",(()=>{a=!0,d()}))),e.stopOnFocusIn&&(w.add(I,\"focusin\",(()=>{f(),i.scrollTo(i.selectedScrollSnap(),!0)})),e.stopOnInteraction||w.add(I,\"focusout\",d)),e.playOnInit&&d()},destroy:function(){i.off(\"pointerDown\",f).off(\"pointerUp\",g).off(\"settle\",p),f(),r=!0,l=!1},play:function(t){void 0!==t&&(s=t),a=!0,d()},stop:function(){l&&f()},reset:function(){l&&(f(),g())},isPlaying:function(){return l}}}return o.globalOptions=void 0,o}));\n// auto-height\n!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(e=\"undefined\"!=typeof globalThis?globalThis:e||self).EmblaCarouselAutoHeight=t()}(this,(function(){\"use strict\";function e(e={}){let t,n=[];const o=[\"select\",\"slideFocus\"];function i(){t.containerNode().style.height=`${function(){const{slideRegistry:e}=t.internalEngine();return e[t.selectedScrollSnap()].map((e=>n[e])).reduce(((e,t)=>Math.max(e,t)),0)}()}px`}return{name:\"autoHeight\",options:e,init:function(e){t=e;const{options:{axis:s},slideRects:l}=t.internalEngine();\"y\"!==s&&(n=l.map((e=>e.height)),o.forEach((e=>t.on(e,i))),i())},destroy:function(){o.forEach((e=>t.off(e,i)));const e=t.containerNode();e.style.height=\"\",e.getAttribute(\"style\")||e.removeAttribute(\"style\")}}}return e.globalOptions=void 0,e}));"],"names":["n","t","e","r","Object","prototype","toString","call","o","Math","abs","i","sign","u","f","map","Number","s","a","max","length","l","Array","from","keys","m","MouseEvent","g","add","passive","c","addEventListener","removeEventListener","addListener","removeListener","push","clear","filter","x","min","constrain","reachedAny","reachedMax","reachedMin","removeOffset","ceil","I","get","set","subtract","A","scroll","style","transform","getAttribute","removeAttribute","to","direction","toggleActive","z","align","axis","container","slides","containScroll","slidesToScroll","inViewThreshold","breakpoints","dragFree","dragThreshold","loop","skipSnaps","duration","startIndex","active","watchDrag","watchResize","watchSlides","watchFocus","assign","arguments","hasOwnProperty","apply","Error","freeze","values","forEach","isFrozen","window","innerHeight","preventWheelAction","reverseSign","wheelDraggingClass","forceWheelAxis","target","isNaN","snapped","inView","draggable","dragging","classList","contains","remove","delay","jump","playOnInit","stopOnFocusIn","stopOnInteraction","stopOnMouseEnter","stopOnLastSnap","rootNode","speed","startDelay"],"version":3,"file":"embla-carousel.umd.js.map"}